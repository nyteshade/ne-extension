{
  "version": 3,
  "sources": ["../../src/index.js", "../../src/errors/CannotBeExtendedError.js", "../../src/errors/MissingOwnerValue.js", "../../src/patchtoggle.js", "../../src/patch.js", "../../src/extension.js"],
  "sourcesContent": ["export { Extension } from './extension.js'\nexport { Patch } from './patch.js'\nexport { PatchToggle } from './patchtoggle.js'\n\nimport { CannotBeExtendedError } from './errors/CannotBeExtendedError.js'\nimport { MissingOwnerValue } from './errors/MissingOwnerValue.js'\n\nexport const Errors = {\n  get CannotBeExtended() { return CannotBeExtendedError },\n  get MissingOwnerValue() { return MissingOwnerValue },\n}\n", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1]\n\n/**\n * Represents an error that is thrown when there is an attempt to extend a\n * restricted part of the code. This error is specifically used to signal\n * violations of extension constraints, such as tampering with certain keys\n * or properties of an object. The error message constructed will include the\n * details of the owner (the restricted part) and the key that was attempted to\n * be tampered with.\n */\nexport class CannotBeExtendedError extends Error {\n  /**\n   * Constructs a new CannotBeExtendedError instance.\n   *\n   * @param {string} owner The name or identifier of the restricted part\n   * that is disallowing extension or tampering.\n   * @param {string} key The key or property that was attempted to be\n   * modified or extended.\n   */\n  constructor(owner, key) {\n    super(`${typeOf(owner)} disallows tampering with ${key}.`)\n    Object.assign(this, { owner, key })\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Overrides the default\n   * Object.prototype.toString behavior, returning the constructor's name\n   * of this error instance. Useful for debugging and logging purposes.\n   * @returns {string} The name of the constructor for this error instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}\n", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1]\n\n/**\n * Represents an error that is thrown when a property is missing from a specified\n * owner object. This error is used to indicate that a specific key or property\n * expected to be present on the owner is not found, highlighting potential issues\n * in property access or data integrity.\n */\nexport class MissingOwnerValue extends Error {\n  /**\n   * Constructs a new MissingOwnerValue instance.\n   *\n   * @param {string} owner The object or entity that is supposed to contain the\n   * property.\n   * @param {string} key The name of the property that is missing from the owner.\n   */\n  constructor(owner, key) {\n    super(`${typeOf(owner)} does not have a property named '${key}'.`)\n    Object.assign(this, { owner, key })\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Overrides the default\n   * Object.prototype.toString behavior, returning the constructor's name\n   * of this error instance. Useful for debugging and logging purposes.\n   *\n   * @returns {string} The name of the constructor for this error instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}\n", "import { Patch } from \"./patch\";\n\n/**\n * Early usage of the Patch and Extension classes made it clear that it was\n * cumbersome to use a Patch temporarily for a block of code and excessive\n * amounts of if/else statements were required. This simple wrapper makes that\n * process easier.\n */\nexport class PatchToggle {\n  /**\n   * Wraps an instance of a Patch. It allows low-code clean-readability to\n   * start and stop the underlying patch regardless of whether or not the\n   * patch has been already applied.\n   *\n   * @param {Patch} patch instance of `Patch` to wrap with this toggle\n   * @param {boolean} preventRevert prevents the call to `.revert()` on the\n   * supplied patch when stop() is called.\n   */\n  constructor(patch, preventRevert = false) {\n    this.started = false\n    this.preventRevert = preventRevert\n    this.patch = patch\n    this.patchName = (\n      patch.owner?.name ??\n      patch.owner?.constructor?.name ??\n      /(\\w+)]/.exec(Object.prototype.toString.call(patch.owner))[1]\n    )\n    this.state = {\n      needsApplication: false,\n      needsReversion: false,\n    }\n  }\n\n  /**\n   * If the usage of the wrapped Patch hasn't been started yet, the code checks\n   * whether or not the patch has been applied by checking for signs of it in\n   * the owning object.\n   *\n   * If the patch needs to be applied, it will be applied at this time.\n   *\n   * @returns {PatchToggle} returns `this` to allow for chaining\n   */\n  start() {\n    if (!this.started) {\n      this.state.needsApplication = !this.patch.applied\n      this.state.needsReversion = this.patch.applied\n      this.started = true\n\n      if (this.state.needsApplication) {\n        this.patch.apply()\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Checks to see if the toggle has been started. If so, the patch is reverted\n   * if it needed to be applied previously. After stopping, the state of the instance\n   * is reverted to allow for clean subsequent calls to start.\n   *\n   * @returns {PatchToggle} returns `this` to allow further chaining\n   */\n  stop() {\n    if (this.started) {\n      if (this.preventRevert || this.patch.applied) {\n        this.patch.revert()\n      }\n\n      this.state.needsApplication = false\n      this.state.needsReversion = false\n      this.started = false\n    }\n\n    return this\n  }\n\n  /**\n   * When the string tag for this class instance is inspected, it will\n   * reflect the string `PatchToggle:PatchName`\n   */\n  get [Symbol.toStringTag]() {\n    return `${this.constructor.name}:${this.patchName}`\n  }\n\n  /**\n   * Custom inspect function for Node.js that provides a formatted representation\n   * of the PatchToggle instance, primarily for debugging purposes.\n   *\n   * @param {number} depth The depth to which the object should be formatted.\n   * @param {object} options Formatting options.\n   * @param {function} inspect The inspection function to format the object.\n   * @returns {string} A formatted string representing the PatchEntry instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const objName = this[Symbol.toStringTag]\n    const status = `(started: ${this.started} needed: ${this.state.needsApplication})`\n\n    return inspect(`${objName} ${status}`, {...options, depth})\n  }\n}", "import { PatchToggle } from './patchtoggle.js'\n\n/**\n * The Patch class provides a mechanism to apply patches to properties or\n * methods of an object (the owner). It keeps track of the original state of\n * these properties and allows for the application and reversion of patches.\n */\nexport class Patch {\n  /**\n   * Constructs a new Patch instance.\n   *\n   * @param {object} owner The object to which patches will be applied.\n   * @param {object} patches An object containing properties or methods to\n   *                         be patched onto the owner.\n   * @param {object} [options={}] Additional options for patching behavior.\n   */\n  constructor(owner, patches, options = {}) {\n    Object.assign(this, {\n      owner,\n      options,\n      applied: false,\n    })\n\n    this.patchConflicts = {}\n    this.patchEntries = {}\n    this.patchesOwner = patches\n\n    Reflect.ownKeys(patches).forEach(key => {\n      this.patchEntries[key] = new Patch.#PatchEntry(key, this.patchesOwner)\n\n      if (Reflect.has(this.owner, key)) {\n        this.patchConflicts[key] = new Patch.#PatchEntry(key, this.owner)\n      }\n    })\n\n    if (!Patch.patches.has(owner)) {\n      Patch.patches.set(owner, [])\n    }\n\n    Patch.patches.get(owner).push(this)\n  }\n\n  /**\n   * Retrieves the patch entries as an array of [key, patchEntry] pairs.\n   *\n   * @returns {Array} An array of [key, patchEntry] pairs.\n   */\n  get patches() {\n    return Reflect.ownKeys(this.patchEntries).map(key => {\n      return [key, this.patchEntries[key]]\n    })\n  }\n\n  /**\n   * Depending on how the PatchEntry is configured, accessing the patch\n   * by name can be somewhat irritating, so this provides an object with\n   * the actual current patch value at the time patchValues is requested.\n   *\n   * @example let { patch1, patch2 } = patch.patchValues\n   * @returns {object} an object with the patchName mapped to the current\n   * computed patchEntry value.\n   */\n  get patchValues() {\n    return this.patches.reduce((acc, [key, patchEntry]) => {\n      acc[key] = patchEntry.computed\n      return acc\n    }, {})\n  }\n\n  /**\n   * Retrieves the conflict entries (existing properties on the owner that\n   * will be overridden by patches) as an array of [key, patchEntry] pairs.\n   *\n   * @returns {Array} An array of [key, patchEntry] pairs.\n   */\n  get conflicts() {\n    return Reflect.ownKeys(this.patchConflicts).map(key => {\n      return [key, this.patchConflicts[key]]\n    })\n  }\n\n  /**\n   * Applies all patches to the owner object. If a property with the same key\n   * already exists on the owner, it will be overridden.\n   */\n  apply() {\n    if (!this.applied) {\n      this.patches.forEach(([,patch]) => {\n        Object.defineProperty(this.owner, patch.key, patch.descriptor)\n      })\n\n      this.applied = true\n    }\n  }\n\n  /**\n   * Creates an easy to use toggle for working with `Patch` classes\n   *\n   * @param {boolean} preventRevert true if calling stop() on the toggle does not\n   * revert the patch. false, the default, if it should.\n   * @returns {PatchToggle} an instance of PatchToggle wrapped around this instance\n   * of `Patch`\n   * @example const toggle = ObjectExtensions.createToggle().start()\n   */\n  createToggle(preventRevert = false) {\n    return new PatchToggle(this, preventRevert)\n  }\n\n  /**\n   * Reverts all applied patches on the owner object, restoring any overridden\n   * properties to their original state.\n   */\n  revert() {\n    if (this.applied) {\n      this.patches.forEach(([,patch]) => {\n        delete this.owner[patch.key]\n      })\n\n      this.conflicts.forEach(([,patch]) => {\n        Object.defineProperty(this.owner, patch.key, patch.descriptor)\n      })\n\n      this.applied = false\n    }\n  }\n\n  /**\n   * Removes this Patch instance from being tracked amongst all the tracked Patch\n   * instances. The JavaScript virtual machine will clean this instance up once\n   * nothing else is holding a reference to it.\n   */\n  release() {\n    const patches = Patch.patches.get(this.owner)\n    patches.splice(patches.find(e => e === this), 1)\n  }\n\n  /**\n   * The object to which the patches are applied.\n   */\n  owner = null\n\n  /**\n   * Additional options for patching behavior.\n   */\n  options = null\n\n  /**\n   * A global mapping of all patches in play\n   */\n  static patches = new Map()\n\n  /**\n   * Applies all patches associated with a given owner object. This method\n   * is used to enable all patches for a specific owner if they have been\n   * previously registered.\n   *\n   * @param {object} owner The object whose patches are to be applied.\n   */\n  static enableFor(owner) {\n    if (Patch.patches.has(owner)) {\n      for (const patch of Patch.patches.get(owner)) {\n        patch.apply()\n      }\n    }\n  }\n\n  /**\n   * Reverts all patches associated with a given owner object. This method\n   * is used to disable all patches for a specific owner if they have been\n   * previously applied.\n   *\n   * @param {object} owner The object whose patches are to be reverted.\n   */\n  static disableFor(owner) {\n    if (Patch.patches.has(owner)) {\n      for (const patch of Patch.patches.get(owner)) {\n        patch.revert()\n      }\n    }\n  }\n\n  /**\n   * Internal class representing a single patch entry.\n   */\n  static #PatchEntry = class {\n    /**\n     * Constructs a new PatchEntry instance.\n     *\n     * @param {string} property The property key to be patched.\n     * @param {object} [owningObject=globalThis] The object from which the\n     * property descriptor is taken.\n     */\n    constructor(property, owningObject = globalThis) {\n      Object.assign(this, {\n        key: property,\n        descriptor: Object.getOwnPropertyDescriptor(owningObject, property),\n        owner: owningObject\n      })\n    }\n\n    /**\n     * Computes and returns the current value of the patch, based on its type\n     * (data or accessor).\n     *\n     * @returns {any} The current value of the patch.\n     */\n    get computed() {\n      if (this.isAccessor) {\n        return this.descriptor.get.bind(this.owner).call()\n      }\n      else {\n        return this.descriptor.value\n      }\n    }\n\n    /**\n     * Checks if the patch is a data property (has a value).\n     *\n     * @returns {boolean} True if the patch is a data property, false otherwise.\n     */\n    get isData() {\n      return Reflect.has(this.descriptor, 'value')\n    }\n\n    /**\n     * Checks if the patch is an accessor property (has a getter).\n     *\n     * @returns {boolean} True if the patch is an accessor property, false otherwise.\n     */\n    get isAccessor() {\n      return Reflect.has(this.descriptor, 'get')\n    }\n\n    /**\n     * Checks if the patch is read-only (not configurable or not writable).\n     *\n     * @returns {boolean} True if the patch is read-only, false otherwise.\n     */\n    get isReadOnly() {\n      return (\n        (Reflect.has(this.descriptor, 'configurable') && !this.descriptor.configurable) ||\n        (Reflect.has(this.descriptor, 'writable') && !this.descriptor.writable)\n      )\n    }\n\n    /**\n     * Custom getter for the toStringTag symbol. Provides the class name of\n     * the PatchEntry instance.\n     *\n     * @returns {string} The class name of the PatchEntry instance.\n     */\n    get [Symbol.toStringTag]() {\n      return this.constructor.name\n    }\n\n    /**\n     * Custom inspect function for Node.js that provides a formatted representation\n     * of the PatchEntry instance, primarily for debugging purposes.\n     *\n     * @param {number} depth The depth to which the object should be formatted.\n     * @param {object} options Formatting options.\n     * @param {function} inspect The inspection function to format the object.\n     * @returns {string} A formatted string representing the PatchEntry instance.\n     */\n    [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n      return `PatchEntry<${\n        this.key\n      }, ${\n        this.isData ? 'Data' : 'Accessor'\n      }${this.isReadOnly ? ' [ReadOnly]' : ''}>`\n    }\n  }\n}", "import { CannotBeExtendedError } from \"./errors/CannotBeExtendedError.js\"\nimport { MissingOwnerValue } from './errors/MissingOwnerValue.js'\nimport { Patch } from './patch.js'\n\n/**\n * The Extension class, inheriting from the Patch class, is specifically designed\n * for extending properties or methods of a given object. It facilitates the\n * extension process by determining the target key and value for the extension and\n * ensuring the target property is writable and configurable. If these conditions\n * are not met, the class throws a CannotBeExtendedError. This class is useful\n * in scenarios like testing, dynamic behavior adjustments, or managing complex\n * object configurations.\n */\nexport class Extension extends Patch {\n  /**\n   * Constructs a new Extension instance. This constructor initializes the extension\n   * by determining the target key and value for the extension and ensuring that\n   * the property to be extended is configurable and writable. It throws an error\n   * if these conditions are not satisfied. The constructor leverages the Patch\n   * class's functionalities to manage the extension effectively.\n   *\n   * @param {Function|string} keyClassOrFn - The key, class, or function to be\n   * used for the extension. If a function or class is provided, its name is used\n   * as the key.\n   * @param {*} value - The value or method to be used for the extension.\n   * @param {object} [owner=globalThis] - The object to which the extension will\n   * be applied.\n   * @param {object} [options={}] - Additional options for the extension behavior.\n   * @throws {CannotBeExtendedError} If the target property is not writable or\n   * configurable.\n   * @throws {MissingOwnerValue} If the `keyClassOrFn` value is null or there\n   * is an error determining the key and extension values, MissingOwnerValue is\n   * thrown.\n   */\n  constructor(keyClassOrFn, value, owner = globalThis, options = {}) {\n    let { key, extension, valid } = Extension.determineInput(keyClassOrFn)\n    extension = value || extension\n\n    if (!valid) {\n      throw new MissingOwnerValue(owner, key)\n    }\n\n    const descriptor = Object.getOwnPropertyDescriptor(owner, key)\n    if (descriptor) {\n      if (\n        (Reflect.has(descriptor, 'writable') && !descriptor.writable) ||\n        (Reflect.has(descriptor, 'configurable') && !descriptor.configurable)\n      ) {\n        throw new CannotBeExtendedError(owner, key)\n      }\n    }\n\n    super(owner, { [key]: extension }, options)\n    this.key = key\n  }\n\n  /**\n   * Determines the input type for the extension. This method processes the input\n   * and identifies the key for the extension and the associated value or method.\n   * It supports inputs as either a string key or a function/class, providing\n   * flexibility in defining extensions.\n   *\n   * @param {Function|string} keyClassOrFn - The key, class, or function provided\n   * as input. If a function or class is provided, its name is used as the key.\n   * containing the determined key, the extension value/method, and a validity flag\n   * indicating whether the input is usable.\n   * @returns {{key: string|null, extension: *|null, valid: boolean}} An object\n   */\n  static determineInput(keyClassOrFn) {\n    let input = { key: null, extension: null, valid: false }\n\n    if (keyClassOrFn instanceof Function) {\n      input = { key: keyClassOrFn.name, extension: keyClassOrFn, valid: true }\n    }\n    else if (typeof keyClassOrFn === 'string' || keyClassOrFn instanceof String) {\n      input = { key: keyClassOrFn, extension: null, valid: true }\n    }\n\n    return input\n  }\n\n  /**\n   * Custom inspect function for Node.js that provides a formatted representation\n   * of the Extension instance, primarily for debugging purposes.\n   *\n   * @param {number} depth The depth to which the object should be formatted.\n   * @param {object} options Formatting options.\n   * @param {function} inspect The inspection function to format the object.\n   * @returns {string} A formatted string representing the Extension instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    return `Extension<${this.key}>`\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Provides the class name when the\n   * object is converted to a string, typically used for debugging and logging.\n   *\n   * @returns {string} The class name of the Extension instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}"],
  "mappings": "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",
  "names": ["src_exports", "__export", "Errors", "Extension", "Patch", "PatchToggle", "typeOf", "o", "CannotBeExtendedError", "owner", "key", "typeOf", "o", "MissingOwnerValue", "owner", "key", "PatchToggle", "patch", "preventRevert", "depth", "options", "inspect", "objName", "status", "Patch", "_Patch", "owner", "patches", "options", "key", "#PatchEntry", "acc", "patchEntry", "patch", "preventRevert", "PatchToggle", "property", "owningObject", "depth", "inspect", "Extension", "_Extension", "Patch", "keyClassOrFn", "value", "owner", "options", "key", "extension", "valid", "MissingOwnerValue", "descriptor", "CannotBeExtendedError", "input", "depth", "inspect", "Errors", "CannotBeExtendedError", "MissingOwnerValue"]
}
