{
  "version": 3,
  "sources": ["../../src/index.js", "../../src/errors/CannotBeExtendedError.js", "../../src/errors/MissingOwnerValue.js", "../../src/patchtoggle.js", "../../src/patchentry.js", "../../src/patch.js", "../../src/extension.js"],
  "sourcesContent": ["export { Extension } from './extension.js'\nexport { Patch } from './patch.js'\nexport { PatchEntry } from './patchentry.js'\nexport { PatchToggle } from './patchtoggle.js'\n\nimport { CannotBeExtendedError } from './errors/CannotBeExtendedError.js'\nimport { MissingOwnerValue } from './errors/MissingOwnerValue.js'\n\nexport const Errors = {\n  get CannotBeExtended() { return CannotBeExtendedError },\n  get MissingOwnerValue() { return MissingOwnerValue },\n}\n", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1]\n\n/**\n * Represents an error that is thrown when there is an attempt to extend a\n * restricted part of the code. This error is specifically used to signal\n * violations of extension constraints, such as tampering with certain keys\n * or properties of an object. The error message constructed will include the\n * details of the owner (the restricted part) and the key that was attempted to\n * be tampered with.\n */\nexport class CannotBeExtendedError extends Error {\n  /**\n   * Constructs a new CannotBeExtendedError instance.\n   *\n   * @param {string} owner The name or identifier of the restricted part\n   * that is disallowing extension or tampering.\n   * @param {string} key The key or property that was attempted to be\n   * modified or extended.\n   */\n  constructor(owner, key) {\n    super(`${typeOf(owner)} disallows tampering with ${key}.`)\n    Object.assign(this, { owner, key })\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Overrides the default\n   * Object.prototype.toString behavior, returning the constructor's name\n   * of this error instance. Useful for debugging and logging purposes.\n   * @returns {string} The name of the constructor for this error instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}\n", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1]\n\n/**\n * Represents an error that is thrown when a property is missing from a specified\n * owner object. This error is used to indicate that a specific key or property\n * expected to be present on the owner is not found, highlighting potential issues\n * in property access or data integrity.\n */\nexport class MissingOwnerValue extends Error {\n  /**\n   * Constructs a new MissingOwnerValue instance.\n   *\n   * @param {string} owner The object or entity that is supposed to contain the\n   * property.\n   * @param {string} key The name of the property that is missing from the owner.\n   */\n  constructor(owner, key) {\n    super(`${typeOf(owner)} does not have a property named '${key}'.`)\n    Object.assign(this, { owner, key })\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Overrides the default\n   * Object.prototype.toString behavior, returning the constructor's name\n   * of this error instance. Useful for debugging and logging purposes.\n   *\n   * @returns {string} The name of the constructor for this error instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}\n", "import { Patch } from \"./patch.js\";\n\n/**\n * Early usage of the Patch and Extension classes made it clear that it was\n * cumbersome to use a Patch temporarily for a block of code and excessive\n * amounts of if/else statements were required. This simple wrapper makes that\n * process easier.\n */\nexport class PatchToggle {\n  /**\n   * Wraps an instance of a Patch. It allows low-code clean-readability to\n   * start and stop the underlying patch regardless of whether or not the\n   * patch has been already applied.\n   *\n   * @param {Patch} patch instance of `Patch` to wrap with this toggle\n   * @param {boolean} preventRevert prevents the call to `.revert()` on the\n   * supplied patch when stop() is called.\n   */\n  constructor(patch, preventRevert = false) {\n    this.started = false\n    this.preventRevert = preventRevert\n    this.patch = patch\n    this.patchName = (\n      patch.owner?.name ??\n      patch.owner?.constructor?.name ??\n      /(\\w+)]/.exec(Object.prototype.toString.call(patch.owner))[1]\n    )\n    this.state = {\n      needsApplication: false,\n      needsReversion: false,\n    }\n  }\n\n  /**\n   * If the usage of the wrapped Patch hasn't been started yet, the code checks\n   * whether or not the patch has been applied by checking for signs of it in\n   * the owning object.\n   *\n   * If the patch needs to be applied, it will be applied at this time.\n   *\n   * @returns {PatchToggle} returns `this` to allow for chaining\n   */\n  start() {\n    if (!this.started) {\n      this.state.needsApplication = !this.patch.applied\n      this.state.needsReversion = this.patch.applied\n      this.started = true\n\n      if (this.state.needsApplication) {\n        this.patch.apply()\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Checks to see if the toggle has been started. If so, the patch is reverted\n   * if it needed to be applied previously. After stopping, the state of the instance\n   * is reverted to allow for clean subsequent calls to start.\n   *\n   * @returns {PatchToggle} returns `this` to allow further chaining\n   */\n  stop() {\n    if (this.started) {\n      if (this.preventRevert || this.patch.applied) {\n        this.patch.revert()\n      }\n\n      this.state.needsApplication = false\n      this.state.needsReversion = false\n      this.started = false\n    }\n\n    return this\n  }\n\n  /**\n   * When the string tag for this class instance is inspected, it will\n   * reflect the string `PatchToggle:PatchName`\n   */\n  get [Symbol.toStringTag]() {\n    return `${this.constructor.name}:${this.patchName}`\n  }\n\n  /**\n   * Custom inspect function for Node.js that provides a formatted representation\n   * of the PatchToggle instance, primarily for debugging purposes.\n   *\n   * @param {number} depth The depth to which the object should be formatted.\n   * @param {object} options Formatting options.\n   * @param {function} inspect The inspection function to format the object.\n   * @returns {string} A formatted string representing the PatchEntry instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const objName = this[Symbol.toStringTag]\n    const status = `(started: ${this.started} needed: ${this.state.needsApplication})`\n\n    return inspect(`${objName} ${status}`, {...options, depth})\n  }\n}", "/**\n * A PatchEntry class is a wrapper that maps the descriptor, key and owning\n * object in a single instance. When a Patch or Extension are created, one\n * of these for each patch is created so that the patch can be applied and\n * reverted.\n */\nexport class PatchEntry {\n\n  /**\n   * Constructs a new PatchEntry instance, encapsulating the logic for\n   * patching a property onto an object with optional conditions and\n   * descriptor overrides.\n   *\n   * This constructor validates the provided property and owningObject,\n   * constructs a property descriptor by merging the existing descriptor\n   * (if any) with any provided overrides, and initializes the PatchEntry\n   * instance with these details.\n   *\n   * @param {string|symbol} property The property key to patch. Must be a\n   * non-null string or symbol.\n   * @param {object} [owningObject=globalThis] The object to which the\n   * property will be patched. Defaults to the global object.\n   * @param {Function} [condition=undefined] An optional function that\n   * determines if the patch should be applied. If undefined, the patch\n   * is always applied.\n   * @param {object} [descriptorOverrides={}] Optional overrides for the\n   * property descriptor of the patch.\n   * @throws {TypeError} If `property` is not a string or symbol, or if\n   * `owningObject` is not an object.\n   */\n  constructor(\n    property,\n    owningObject = globalThis,\n    condition = undefined,\n    descriptorOverrides = {}\n  ) {\n    const isNullish = (value) => (value === null || value === undefined)\n    const isKey = (value, types = ['string', 'symbol']) =>\n      !isNullish(value) && (!!types.find(f => f === (typeof value)))\n    const isObject = value => isKey(value, ['object'])\n\n    if (!isKey(property)) {\n      console.error(\n        'Property', property, `(type: ${typeof property})`,\n        'owningObject', owningObject, `(type: ${typeof owningObject})`,\n        'condition', condition, `(type: ${typeof condition})`,\n      )\n      throw new TypeError(\n        'Property must be non-null and either a string or symbol'\n      )\n    }\n\n    if (!isObject(owningObject)) {\n      throw new TypeError(\n        'Cannot create Patch entry as owning object is invalid'\n      )\n    }\n\n    const descriptor = {\n      ...Object.getOwnPropertyDescriptor(owningObject, property),\n      ...Object(descriptorOverrides)\n    }\n\n    Object.assign(this, {\n      key: property,\n      descriptor,\n      owner: owningObject,\n      condition: (typeof condition === 'function') ? condition : undefined\n    })\n  }\n\n  /**\n   * Computes and returns the current value of the patch, based on its type\n   * (data or accessor).\n   *\n   * @returns {any} The current value of the patch.\n   */\n  get computed() {\n    if (this.isAccessor) {\n      return this.descriptor.get.bind(this.owner).call()\n    }\n    else {\n      return this.descriptor.value\n    }\n  }\n\n  /**\n   * Checks if the patch is a data property (has a value).\n   *\n   * @returns {boolean} True if the patch is a data property, false otherwise.\n   */\n  get isData() {\n    return Reflect.has(this.descriptor, 'value')\n  }\n\n  /**\n   * Checks if the patch is an accessor property (has a getter).\n   *\n   * @returns {boolean} True if the patch is an accessor property, false otherwise.\n   */\n  get isAccessor() {\n    return Reflect.has(this.descriptor, 'get')\n  }\n\n  /**\n   * Checks if the patch is read-only (not configurable or not writable).\n   *\n   * @returns {boolean} True if the patch is read-only, false otherwise.\n   */\n  get isReadOnly() {\n    return (\n      (Reflect.has(this.descriptor, 'configurable') && !this.descriptor.configurable) ||\n      (Reflect.has(this.descriptor, 'writable') && !this.descriptor.writable)\n    )\n  }\n\n  /**\n   * If a `condition` is associated with this specific patch entry, then it will\n   * run and its result will be returned. Otherwise `true` is returned allowing\n   * all non-conditional `PatchEntry` instances to be applied every time.\n   *\n   * @returns {boolean} `true` if the condition is true or there is no condition\n   * applied to this instance. `false` if the condition fails.\n   */\n  get isAllowed() {\n    const validAndPresent = (\n      this.condition &&\n      typeof this.condition === 'function'\n    )\n\n    return validAndPresent ? this.condition() : true\n  }\n\n  /**\n   * Applies the patch entry to a given object. This method takes the\n   * descriptor from the current patch entry and defines it on the target\n   * object. If `bindAccessors` is true and the descriptor contains accessor\n   * methods (getters/setters), they will be bound to the original owner of\n   * the patch before being applied to ensure the correct `this` context.\n   *\n   * @param {object} anotherObject - The object to which the patch will be\n   * applied.\n   * @param {boolean} [bindAccessors=false] - Whether to bind accessor methods\n   * to the patch's owner.\n   */\n  applyTo(anotherObject, bindAccessors = false) {\n    const descriptor = { ...this.descriptor }\n\n    if (bindAccessors) {\n      if (typeof descriptor.get === 'function') {\n        descriptor.get = descriptor.get.bind(this.owner);\n      }\n      if (typeof descriptor.set === 'function') {\n        descriptor.set = descriptor.set.bind(this.owner);\n      }\n    }\n\n    Object.defineProperty(anotherObject, this.key, descriptor);\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Provides the class name of\n   * the PatchEntry instance.\n   *\n   * @returns {string} The class name of the PatchEntry instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Custom inspect function for Node.js that provides a formatted representation\n   * of the PatchEntry instance, primarily for debugging purposes.\n   *\n   * @param {number} depth The depth to which the object should be formatted.\n   * @param {object} options Formatting options.\n   * @param {function} inspect The inspection function to format the object.\n   * @returns {string} A formatted string representing the PatchEntry instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const name = `\\x1b[33m${this.key}\\x1b[39m`\n    const type = this.isData ? ' Data' : ' Accessor'\n    const writable = this.isReadOnly ? ' [\\x1b[2;3mReadOnly\\x1b[22;23m]' : ''\n\n    return `PatchEntry<${name}${type}${writable}>`\n  }\n}\n", "import { PatchToggle } from './patchtoggle.js'\nimport { PatchEntry } from './patchentry.js'\n\n/**\n * The Patch class provides a mechanism to apply patches to properties or\n * methods of an object (the owner). It keeps track of the original state of\n * these properties and allows for the application and reversion of patches.\n */\nexport class Patch {\n  /**\n   * A record of conflicts between existing and patched properties or methods.\n   * This object maps property names to their respective PatchEntry instances,\n   * which contain information about the original and patched values.\n   *\n   * @type {object}\n   */\n  patchConflicts = Object.create(null)\n\n  /**\n   * An object to store patch entries. Each key corresponds to a property or\n   * method name on the owner object, and the value is the associated\n   * PatchEntry instance which contains the patched and original values.\n   *\n   * @type {object}\n   */\n  patchEntries = Object.create(null)\n\n  /**\n   * The object containing the patches to be applied to the owner. It is\n   * initially undefined and will be populated with the patches passed to the\n   * constructor.\n   *\n   * @type {object}\n   */\n  patchesOwner = undefined\n\n  /**\n   * The count of patches that have been applied. This is incremented\n   * each time a patch is applied and decremented when a patch is\n   * reverted.\n   *\n   * @type {number}\n   */\n  patchCount = 0\n\n  /**\n   * The number of patches that have been successfully applied. This count\n   * is incremented after each successful patch application and decremented\n   * when a patch is reverted.\n   *\n   * @type {number}\n   */\n  patchesApplied = 0\n\n\n  /**\n   * The `displayName` property is used to store a human-readable name for the\n   * Patch instance. This name can be used for logging or debugging purposes to\n   * easily identify the patch in a more meaningful way than a generic identifier\n   * or memory reference. It is initially set to `undefined` and can be updated\n   * to any string value as needed.\n   *\n   * @type {string|undefined}\n   */\n  ownerDisplayName = undefined\n\n  /**\n   * Constructs a new Patch instance. Supported options for Patch instances\n   * include either a global condition for the Patch to be applied or\n   * specific property conditions subjecting only a subset of the patches\n   * to conditional application.\n   *\n   * @example\n   * ```\n   * const custom = Symbol.for('nodejs.util.inspect.custom')\n   * const patch = new Patch(\n   *   Object,\n   *   {\n   *     property: 'value',\n   *     [custom](depth, options, inspect) {\n   *       // ... custom return string for nodejs\n   *     }\n   *   },\n   *   {\n   *     conditions: {\n   *       [custom]() { return process?.versions?.node !== null },\n   *     },\n   *   }\n   * )\n   * patch.apply() // applies `property` but only applies the `custom`\n   *               // property if the JavaScript is running in NodeJS\n   * ```\n   *\n   * @param {object} owner The object to which patches will be applied.\n   * @param {object} patches An object containing properties or methods to\n   *                         be patched onto the owner.\n   * @param {object} [options=Object.create(null)] Additional options for\n   * patching behavior.\n   */\n  constructor(owner, patches, options = Object.create(null)) {\n    Object.assign(this, {\n      owner,\n      options,\n    })\n\n    this.ownerDisplayName = options?.displayName ?? Patch.extractName(owner)\n    this.patchesOwner = Patch.constructWithStore(patches, this)\n    this.generatePatchEntries(this.patchesOwner)\n\n    if (!Patch.patches.has(owner)) {\n      Patch.patches.set(owner, [])\n    }\n\n    Patch.patches.get(owner).push(this)\n  }\n\n  /**\n   * Iterates over the properties of `patchesOwner` and attempts to generate\n   * patches based on the provided conditions and overrides. This method\n   * supports conditional patching, allowing patches to be applied only if\n   * certain conditions are met. It also handles descriptor overrides for\n   * patch symbols, enabling custom behavior for patched properties.\n   *\n   * @param {object} patchesOwner The object containing the patches to be\n   * applied. Each key in this object represents a property to be patched.\n   * @param {object} [overrides] Optional. An object containing descriptor\n   * overrides for the properties to be patched. If not provided, overrides\n   * will be determined based on patch symbols.\n   */\n  generatePatchEntries(patchesOwner, overrides = undefined) {\n    const globalCondition = this?.options.condition\n\n    Reflect.ownKeys(patchesOwner).forEach(key => {\n      const condition = this?.options?.conditions?.[key] ?? globalCondition\n\n      try {\n        const useOverrides = (\n          overrides ??\n          Patch.getDescriptorOverridesFromSymbol(key)\n        );\n        let useOwner = patchesOwner;\n\n        if (Patch.isKnownPatchSymbol(key)) {\n          useOwner = Patch.constructWithStore(patchesOwner[key], this, key)\n          patchesOwner[key] = useOwner\n          this.generatePatchEntries(useOwner, useOverrides);\n          return;\n        }\n\n        this.patchEntries[key] = new PatchEntry(\n          key, patchesOwner, condition, overrides\n        )\n        this.patchCount += 1\n      }\n      catch (error) {\n        console.error(`Failed to process patch for ${String(key)}\\n`, error)\n      }\n\n      if (Reflect.has(this.owner, key)) {\n        try {\n          this.patchConflicts[key] = new PatchEntry(key, this.owner)\n        }\n        catch (error) {\n          console.error(`Cannot capture conflicting patch key ${key}\\n`, error)\n        }\n      }\n    })\n  }\n\n  /**\n   * Retrieves the patch entries as an array of [key, patchEntry] pairs.\n   *\n   * @returns {Array} An array of [key, patchEntry] pairs.\n   */\n  get entries() {\n    return Reflect.ownKeys(this.patchEntries).map(key => {\n      return [key, this.patchEntries[key]]\n    })\n  }\n\n  /**\n   * Retrieves an array of patch entries that have been successfully applied.\n   * Each entry is a key-value pair array where the key is the patch identifier\n   * and the value is the corresponding `PatchEntry` object. Only patches with\n   * a state of `true` in `patchState` are included, indicating they are\n   * currently applied to the owner object.\n   *\n   * @returns {Array} An array of [key, patchEntry]\n   * pairs representing the applied patches.\n   */\n  get appliedEntries() {\n    return Reflect.\n      ownKeys(this.patchEntries).\n      filter(key => this.patchState.get(key) === true).\n      map(key => {\n        return [key, this.patchEntries[key]]\n      })\n  }\n\n  /**\n   * Retrieves an array of patch entries that have not been applied. Each entry\n   * is a key-value pair array where the key is the patch identifier and the\n   * value is the corresponding `PatchEntry` object. Only patches with a state\n   * of `false` in `patchState` are included, indicating they are not currently\n   * applied to the owner object.\n   *\n   * @returns {Array} An array of [key, patchEntry]\n   * pairs representing the unapplied patches.\n   */\n  get unappliedEntries() {\n    return Reflect.\n      ownKeys(this.patchEntries).\n      filter(key => this.patchState.get(key) === false).\n      map(key => {\n        return [key, this.patchEntries[key]]\n      })\n  }\n\n  /**\n   * Depending on how the PatchEntry is configured, accessing the patch\n   * by name can be somewhat irritating, so this provides an object with\n   * the actual current patch value at the time patchValues is requested.\n   *\n   * @example let { patch1, patch2 } = patch.patchValues\n   * @returns {object} an object with the patchName mapped to the current\n   * computed patchEntry value.\n   */\n  get patches() {\n    return this.entries.reduce((acc, [key, patchEntry]) => {\n      acc[key] = patchEntry.computed\n      return acc\n    }, Object.create(null))\n  }\n\n  /**\n   * Retrieves an object containing all patches that have been successfully\n   * applied. The object's keys are the patch keys, and the values are the\n   * computed values of the corresponding patch entries. Only patches with\n   * a state of `true` in `patchState` are considered applied.\n   *\n   * @returns {object} An object mapping each applied patch key to its\n   * computed value.\n   */\n  get appliedPatches() {\n    return this.entries.reduce((acc, [key, patchEntry]) => {\n      if (this.patchState.get(key) === true) {\n        acc[key] = patchEntry.computed\n      }\n      return acc\n    }, Object.create(null))\n  }\n\n  /**\n   * Retrieves an object containing all patches that have not been applied.\n   * The object's keys are the patch keys, and the values are the computed\n   * values of the corresponding patch entries. Only patches with a state\n   * of `false` in `patchState` are considered unapplied.\n   *\n   * @example\n   * // Assuming `patch` is an instance of `Patch` and `patch1` is unapplied:\n   * let unapplied = patch.unappliedPatches;\n   * console.log(unapplied); // { patch1: computedValueOfPatch1 }\n   *\n   * @returns {object} An object mapping each unapplied patch key to its\n   * computed value.\n   */\n  get unappliedPatches() {\n    return this.entries.reduce((acc, [key, patchEntry]) => {\n      if (this.patchState.get(key) === false) {\n        acc[key] = patchEntry.computed\n      }\n      return acc\n    }, Object.create(null))\n  }\n\n  /**\n   * Retrieves an array of patch keys.\n   *\n   * This getter returns an array containing only the keys of the patch entries,\n   * which can be useful for iterating over the patches or checking for the\n   * existence of specific patches by key.\n   *\n   * @returns {string[]} An array of patch keys.\n   */\n  get patchKeys() {\n    return this.entries.map(([key, _]) => key)\n  }\n\n  /**\n   * Generates a list of entries with enhanced string representations. This\n   * getter iterates over the `entries` property, transforming each [key, value]\n   * pair into a more informative string object. This is particularly useful\n   * for debugging or logging, as it provides a clear, readable format for\n   * each entry. The string representation includes the entry's key and value,\n   * with the key being converted to a string using its `Symbol.toStringTag`,\n   * `name` property, or a direct string conversion as fallback.\n   *\n   * Each value in the resultant array additionally has '.key', `.value`,\n   * `.entry` and `.entries` accessors. The `.key` is the `owner` object, the\n   * `.value` is the `PatchEntry` instance. The entry accessor provides the\n   * key and value in an array as one might expect to find the\n   * `Object.entries()` array and `.entries` is the same as `[stringRef.entry]`\n   * or `[[key, value]]`.\n   *\n   * @returns {Array} An array of string objects, each representing an entry\n   * from the `entries` property. Each string object is enhanced with additional\n   * properties and methods for improved usability and debugging.\n   */\n  get prettyEntries() {\n    const prettyEntries = this.entries.map(([key, value]) => Patch.stringRef(\n      Patch.extractName(key),\n      key,\n      value\n    ))\n\n    Object.defineProperty(prettyEntries, 'asEntries', {\n      get() { return this.map(pe => pe.entry) },\n      enumerable: false,\n      configurable: true,\n    })\n\n    return prettyEntries\n  }\n\n  /**\n   * Retrieves the conflict entries (existing properties on the owner that\n   * will be overridden by patches) as an array of [key, patchEntry] pairs.\n   *\n   * @returns {Array} An array of [key, patchEntry] pairs.\n   */\n  get conflicts() {\n    return Reflect.ownKeys(this.patchConflicts).map(key => {\n      return [key, this.patchConflicts[key]]\n    })\n  }\n\n  /**\n   * Checks to see if the tracked number of applied patches is greater than 0\n   *\n   * @returns {boolean} true if at least one patch has been applied\n   */\n  get applied() {\n    return this.patchesApplied > 0\n  }\n\n  /**\n   * Provided for semantics, but this method is synonymous with {@link applied}.\n   *\n   * @returns {boolean} true if at least one patch has been applied\n   */\n  get isPartiallyPatched() {\n    return this.applied\n  }\n\n  /**\n   * Returns true only when the number of tracked patches matches the number\n   * of applied patches.\n   *\n   * @returns {boolean} true if applied patches is equal to the count of patches\n   */\n  get isFullyPatched() {\n    return this.patchCount == this.patchesApplied\n  }\n\n  /**\n   * Applies all patches to the owner object. If a property with the same key\n   * already exists on the owner, it will be overridden. Optionally a callback\n   * can be supplied to the call to revert. If the callback is a valid function,\n   * it will be invoked with an object containing the results of the reversion\n   * of the patch. The callback receives a single parameter which is an object\n   * of counts. It has the signature:\n   *\n   * ```\n   * type counts = {\n   *   patches: number;\n   *   applied: number;\n   *   errors: Array<PatchEntry,Error>;\n   *   notApplied: number;\n   * }\n   * ```\n   *\n   * While the keys may be obvious to some, `patches` is the count of patches\n   * this instance tracks. `applied` is the number of patches that were applied\n   * 'errors' is an array of arrays where the first element is the `PatchEntry`\n   * and the second element is an `Error` indicating the problem. An error will\n   * only be generated if `isAllowed` is `true` and the patch still failed to\n   * apply Lastly `notApplied` is the number of patches that were unable to\n   * be applied.\n   *\n   * Additional logic that should track\n   * ```\n   *   \u2022 patches should === applied when done\n   *   \u2022 errors.length should be 0 when done\n   *   \u2022 notApplied should be 0 when done\n   * ```\n   *\n   * @param {function} metrics - a callback which receives a status of the\n   * `revert` action if supplied. This callback will not be invoked, nor will\n   * any of the other logic be captured, if {@link applied} returns false\n   */\n  apply(metrics) {\n    const entries = this.entries\n    const counts = {\n      patches: entries.length,\n      applied: 0,\n      errors: [],\n      notApplied: entries.length,\n    }\n\n    this.patchState.clear()\n\n    entries.forEach(([,patch]) => {\n      if (patch.isAllowed) {\n        // Patch\n        Object.defineProperty(this.owner, patch.key, patch.descriptor)\n\n        // Verify\n        let oDesc = Object.getOwnPropertyDescriptor(this.owner, patch.key)\n        if (this.#equalDescriptors(oDesc, patch.descriptor)) {\n          counts.applied += 1\n          counts.notApplied -= 1\n\n          this.patchState.set(patch, true)\n\n        }\n        else {\n          counts.errors.push([patch, new Error(\n            `Could not apply patch for key ${patch.key}`\n          )])\n          this.patchState.set(patch, false)\n        }\n      }\n      else {\n        this.patchState.set(patch, false)\n      }\n    })\n\n    this.patchesApplied = counts.applied\n\n    if (typeof metrics === 'function') {\n      metrics(counts)\n    }\n  }\n\n  /**\n   * Creates an easy to use toggle for working with `Patch` classes\n   *\n   * @param {boolean} preventRevert true if calling stop() on the toggle does not\n   * revert the patch. false, the default, if it should.\n   * @returns {PatchToggle} an instance of PatchToggle wrapped around this instance\n   * of `Patch`\n   * @example const toggle = ObjectExtensions.createToggle().start()\n   */\n  createToggle(preventRevert = false) {\n    return new PatchToggle(this, preventRevert)\n  }\n\n  /**\n   * Reverts all applied patches on the owner object, restoring any overridden\n   * properties to their original state. Optionally a callback can be supplied to\n   * the call to revert. If the callback is a valid function, it will be invoked\n   * with an object containing the results of the reversion of the patch. The\n   * callback receives a single parameter which is an object of counts. It has\n   * the signature:\n   *\n   * ```\n   * type counts = {\n   *   patches: number;\n   *   reverted: number;\n   *   restored: number;\n   *   conflicts: number;\n   *   errors: Array<PatchEntry,Error>;\n   *   stillApplied: number;\n   * }\n   * ```\n   *\n   * While the keys may be obvious to some, `patches` is the count of patches\n   * this instance tracks. `reverted` is the number of patches that were removed'\n   * `restored` is the number of originally conflicting keys that were restored.\n   * `conflicts` is the total number of conflicts expected. `errors` is an array of\n   * arrays where the first element is the `PatchEntry` and the second element\n   * is an `Error` indicating the problem. Lastly `stillApplied` is the number of\n   * patchesApplied still tracked. If this is greater than zero, you can assume\n   * something went wrong.\n   *\n   * Additional logic that should track\n   * ```\n   *   \u2022 patches should === reverted when done\n   *   \u2022 restored should === conflicts when done\n   *   \u2022 errors.length should be 0 when done\n   *   \u2022 stillApplied should be 0 when done\n   * ```\n   *\n   * @param {function} metrics - a callback which receives a status of the\n   * `revert` action if supplied. This callback will not be invoked, nor will\n   * any of the other logic be captured, if {@link applied} returns false\n   */\n  revert(metrics) {\n    if (!this.applied) {\n      return\n    }\n\n    const entries = this.entries\n    const conflicts = this.conflicts\n\n    const counts = {\n      patches: entries.length,\n      reverted: 0,\n      restored: 0,\n      conflicts: conflicts.length,\n      errors: [],\n      stillApplied: 0,\n    }\n\n    entries.forEach(([,patch]) => {\n      const successful = delete this.owner[patch.key]\n      if (successful) {\n        this.patchesApplied -= 1\n        counts.reverted += 1\n        this.patchState.set(patch, false)\n      }\n      else {\n        counts.errors.push([patch, new Error(\n          `Failed to revert patch ${patch.key}`\n        )])\n      }\n    })\n\n    conflicts.forEach(([,patch]) => {\n      Object.defineProperty(this.owner, patch.key, patch.descriptor)\n      const appliedDescriptor = Object.getOwnPropertyDescriptor(this.owner, patch.key)\n      if (this.#equalDescriptors(patch.descriptor, appliedDescriptor)) {\n        counts.restored += 1\n      }\n      else {\n        counts.errors.push([patch, new Error(\n          `Failed to restore original ${patch.key}`\n        )])\n      }\n    })\n\n    counts.stillApplied = this.patchesApplied\n    if (typeof metrics === 'function') {\n      metrics(counts)\n    }\n  }\n\n  /**\n   * Removes this Patch instance from being tracked amongst all the tracked Patch\n   * instances. The JavaScript virtual machine will clean this instance up once\n   * nothing else is holding a reference to it.\n   */\n  release() {\n    const patches = Patch.patches.get(this.owner)\n    patches.splice(patches.find(e => e === this), 1)\n  }\n\n  /**\n   * The object to which the patches are applied.\n   */\n  owner = null;\n\n  /**\n   * Additional options for patching behavior.\n   */\n  options = null;\n\n  /**\n   * Patches that are currently live and active will have true as their\n   * value and inert or non-applied patches will have false as their\n   * value. The key is always the associated {@link PatchEntry}.\n   */\n  patchState = new Map();\n\n  /**\n   * Creates an iterator for the patch entries, allowing the `Patch` instance to\n   * be directly iterable using a `for...of` loop. Each iteration will yield a\n   * `[key, patchEntry]` pair, where `key` is the property name and `patchEntry`\n   * is the corresponding `PatchEntry` instance.\n   *\n   * @returns {Iterator} An iterator that yields `[key, patchEntry]` pairs.\n   */\n  [Symbol.iterator]() {\n    return this.entries.values()\n  }\n\n  /**\n   * Compares two property descriptor objects to determine if they are equivalent.\n   *\n   * This method checks if both descriptors have the same value for the\n   * `configurable`, `enumerable`, `value`, `writable`, `get`, and `set`\n   * properties. If any of these properties differ between the two descriptors,\n   * the descriptors are considered not equivalent.\n   *\n   * @param {PropertyDescriptor} left - The first descriptor to compare.\n   * @param {PropertyDescriptor} right - The second descriptor to compare.\n   * @returns {boolean} - True if the descriptors are equivalent, false otherwise.\n   * @private\n   */\n  #equalDescriptors(left, right) {\n    if (!left || !right) {\n      return false;\n    }\n\n    return (\n      left.configurable === right.configurable &&\n      left.enumerable === right.enumerable &&\n      left.value === right.value &&\n      left.writable === right.writable &&\n      left.get === right.get &&\n      left.set === right.set\n    )\n  }\n\n  /**\n   * Custom inspection function for Node.js that is called when `util.inspect`\n   * is used to convert the instance to a string. This allows for customizing\n   * the output of `util.inspect` for objects of this class.\n   *\n   * @param {number} depth The current depth of the inspection. If the depth\n   * is less than the recurse times set, it will return the object itself,\n   * otherwise it will return the inspected result.\n   * @param {object} options An object containing options for the inspection.\n   * @param {function} inspect The inspection function provided by Node.js\n   * that can be called to inspect other properties with the same options as\n   * the original call.\n   * @returns {string} A string representation of the instance tailored for\n   * Node.js' `util.inspect`.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const type = this.ownerDisplayName ?? ''\n    const name = (type.length\n      ? `[\\x1b[32m${type}\\x1b[39m]`\n      : ''\n    )\n    const keys = (this.prettyEntries\n      .map(entry => {\n        return `\\x1b[2;33m${entry}\\x1b[22;39m`\n      })\n      .join(', ')\n    )\n\n    return `${this.constructor.name}${name} { ${keys} }`;\n  }\n\n  /**\n   * A global mapping of all patches in play\n   */\n  static patches = new Map()\n\n  /**\n   * Applies all patches associated with a given owner object. This method\n   * is used to enable all patches for a specific owner if they have been\n   * previously registered.\n   *\n   * @param {object} owner The object whose patches are to be applied.\n   */\n  static enableFor(owner) {\n    if (Patch.patches.has(owner)) {\n      for (const patch of Patch.patches.get(owner)) {\n        patch.apply()\n      }\n    }\n  }\n\n  /**\n   * Enables patches for all static members registered in the system. This\n   * method iterates over all registered owners, identifying those represented\n   * by functions (typically static members or classes) and enables patches\n   * specifically for them. It's particularly useful for activating patches\n   * that are meant to modify or enhance static properties or methods of\n   * classes.\n   */\n  static enableProbableStatics() {\n    for (const owner of Patch.patches.keys()) {\n      if (typeof owner !== 'function') {\n        continue;\n      }\n\n      Patch.enableFor(owner);\n    }\n  }\n\n  /**\n   * Iterates over all registered owners and enables patches for those\n   * identified as instance entities (non-functions). This method is\n   * particularly useful for activating patches on instance-level properties\n   * or methods of classes, without affecting static-level patches. It ensures\n   * that only owners not represented by functions, typically instance members,\n   * are targeted for patch enabling.\n   */\n  static enableProbableInstances() {\n    for (const owner of Patch.patches.keys()) {\n      if (typeof owner === 'function') {\n        continue;\n      }\n\n      Patch.enableFor(owner);\n    }\n  }\n\n  /**\n   * Enables all patches for every owner currently registered in the system.\n   * This static method iterates over all owners that have patches registered\n   * and applies those patches by invoking `enableFor` on each owner. This\n   * method is particularly useful when a global application of all patches\n   * is required, without the need to manually enable them for each owner\n   * individually.\n   */\n  static enableAll() {\n    for (const owner of Patch.patches.keys()) {\n      Patch.enableFor(owner);\n    }\n  }\n\n  /**\n   * Reverts all patches associated with a given owner object. This method\n   * is used to disable all patches for a specific owner if they have been\n   * previously applied.\n   *\n   * @param {object} owner The object whose patches are to be reverted.\n   */\n  static disableFor(owner) {\n    if (Patch.patches.has(owner)) {\n      for (const patch of Patch.patches.get(owner)) {\n        patch.revert()\n      }\n    }\n  }\n\n  /**\n   * Disables all patches for every owner currently registered in the system.\n   * This method iterates over all owners that have patches registered and\n   * reverts those patches by invoking `disableFor` on each owner. It is\n   * particularly useful when a global reversion of all patches is required,\n   * without the need to manually disable them for each owner individually.\n   */\n  static disableAll() {\n    for (const owner of Patch.patches.keys()) {\n      Patch.disableFor(owner);\n    }\n  }\n\n  /**\n   * Iterates over all registered owners and disables patches for those\n   * identified as static entities (functions). This method is particularly\n   * useful for reverting patches to static methods or properties of classes,\n   * without affecting instance-level patches. It ensures that only owners\n   * represented by functions, typically static members, are targeted for\n   * patch disabling.\n   */\n  static disableProbableStatics() {\n    for (const owner of Patch.patches.keys()) {\n      if (typeof owner !== 'function') {\n        continue;\n      }\n\n      Patch.disableFor(owner);\n    }\n  }\n\n  /**\n   * Iterates over all registered owners and disables patches for those\n   * not identified as static entities (functions). This method is\n   * particularly useful for reverting patches applied to instance-level\n   * properties or methods, ensuring that patches on static members remain\n   * unaffected. It targets only owners not represented by functions,\n   * typically instance members, for patch disabling.\n   */\n  static disableProbableInstances() {\n    for (const owner of Patch.patches.keys()) {\n      if (typeof owner === 'function') {\n        continue;\n      }\n\n      Patch.disableFor(owner);\n    }\n  }\n\n\n  /**\n   * A static getter that provides a proxy to manage and interact with the\n   * patches that have been applied globally. This proxy abstracts the\n   * underlying details and presents a simplified interface for querying and\n   * manipulating applied patches. It is particularly useful in IDEs, as it\n   * allows developers to access the state of applied patches without needing\n   * to delve into the source code.\n   *\n   * @returns {Object} An object showing all the keys known to be patched for\n   * the default owner, `globalThis`\n   */\n  static get applied() {\n    return this.#allPatchesForOwner(globalThis, true)\n  }\n\n  /**\n   * A static getter that provides access to a proxy representing all known\n   * patches, whether applied or not. This is useful for inspecting the\n   * complete set of patches that have been registered in the system, without\n   * limiting the view to only those that are currently active. The proxy\n   * abstracts the underlying details and presents a simplified interface for\n   * querying and manipulating the patches.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of all\n   * registered patches, allowing for operations like checking if a patch is\n   * known and retrieving patch values.\n   */\n  static get known() {\n    return this.#allPatchesForOwner(globalThis, false)\n  }\n\n  /**\n   * A static getter that provides access to a proxy for managing patch\n   * entries with a toggle functionality. This proxy allows the temporary\n   * application of patches within a certain scope, and automatically reverts\n   * them after the scope ends. It is useful for applying patches in a\n   * controlled manner, ensuring that they do not remain active beyond the\n   * intended usage.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of the\n   * patches with toggle functionality, allowing for temporary application\n   * and automatic reversion of patches.\n   */\n  static get use() {\n    return this.#allPatchesForOwner(globalThis, false, true)\n  }\n\n  /**\n   * A static getter that provides access to a proxy for managing patch\n   * entries with lazy initialization. This proxy defers the creation and\n   * application of patches until they are explicitly requested. It is\n   * beneficial for performance optimization, as it avoids the overhead of\n   * initializing patches that may not be used.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of the\n   * patches with lazy initialization, allowing patches to be created and\n   * applied only when needed.\n   */\n  static get lazy() {\n    return this.#allPatchesForOwner(globalThis, false, false, true)\n  }\n\n  /**\n   * Returns an object with getters to access different proxy views of patches\n   * scoped to a specific owner. This allows for interaction with patches\n   * that are either applied, known, or used within a certain scope, providing\n   * a controlled environment for patch management.\n   *\n   * @param {object} owner - The object to scope the patch proxies to.\n   * @returns {object} An object containing getters for `applied`, `known`,\n   * and `use` proxies:\n   * - `applied`: Proxy for patches applied to the owner.\n   * - `known`: Proxy for all patches known to the owner, applied or not.\n   * - `use`: Proxy that allows temporary application of patches.\n   */\n  static scopedTo(owner) {\n    const allForOwner = (\n      owner,\n      appliedOnly,\n      wrapInToggle = false,\n      applyOnRequest = false\n    ) => {\n      return this.#allPatchesForOwner(\n        owner,\n        appliedOnly,\n        wrapInToggle,\n        applyOnRequest\n      )\n    }\n\n    return {\n      /**\n       * Getter for a proxy that represents patches applied to the owner.\n       * This proxy provides a simplified interface for interacting with\n       * applied patches, such as checking their status or retrieving values.\n       *\n       * @returns {Proxy} A proxy to the applied patches.\n       */\n      get applied() {\n        return allForOwner(owner, true, false)\n      },\n\n      /**\n       * Getter for a proxy that represents all patches known to the owner,\n       * whether they are applied or not. This proxy allows for querying\n       * and manipulation of the patches without directly accessing them.\n       *\n       * @returns {Proxy} A proxy to all known patches.\n       */\n      get known() {\n        return allForOwner(owner, false, false)\n      },\n\n      /**\n       * Getter for a proxy that enables temporary application of patches\n       * within a certain scope. The patches are automatically reverted\n       * after the scope ends, ensuring controlled usage.\n       *\n       * @returns {Proxy} A proxy to patches with toggle functionality.\n       */\n      get use() {\n        return allForOwner(owner, false, true)\n      },\n\n      /**\n       * Getter for a proxy that represents patches that are not immediately\n       * applied but are applied on request. This allows for patches to be\n       * applied only when they are explicitly needed, potentially improving\n       * performance by deferring the application of patches until necessary.\n       *\n       * @returns {Proxy} A proxy to patches that are applied on request.\n       */\n      get lazy() {\n        return allForOwner(owner, false, false, true)\n      },\n    }\n  }\n\n  /**\n   * Aggregates patches for a given owner into a single object, optionally\n   * filtering by applied status and wrapping in a toggle function.\n   *\n   * This method collects all patches associated with the specified owner\n   * and constructs an object where each patch is represented by its key.\n   * If `onlyApplied` is true, only patches that are currently applied will\n   * be included. If `wrapInToggle` is true, each patch will be represented\n   * as a function that temporarily applies the patch when called.\n   *\n   * @param {object} owner - The owner object whose patches are to be\n   * aggregated.\n   * @param {boolean} onlyApplied - If true, only include patches that\n   * are applied.\n   * @param {boolean} [wrapInToggle=false] - If true, wrap patches in a\n   * toggle function for temporary application.\n   * @returns {object} An object representing the aggregated patches, with\n   * each patch keyed by its property name.\n   * @private\n   */\n  static #allPatchesForOwner(\n    owner,\n    onlyApplied,\n    wrapInToggle = false,\n    applyOnRequest = false\n  ) {\n    return [...Patch.patches.values()].\n      flat().\n      filter(patch => patch.owner === owner).\n      reduce((accumulator, patch) => {\n        for (const [,patchEntry] of patch.entries) {\n          if (onlyApplied && patch.patchState.get(patchEntry) !== true) {\n            continue\n          }\n\n          if (wrapInToggle) {\n            accumulator[patchEntry.key] = async (usage) => {\n              if (typeof usage !== 'function') {\n                return\n              }\n\n              const type = Object.prototype.toString.call(usage)\n              const toggle = patch.createToggle()\n\n              toggle.start()\n              if('[object AsyncFunction]' === type) {\n                await usage(patchEntry.computed, patchEntry)\n              }\n              else {\n                usage(patchEntry.computed, patchEntry)\n              }\n              toggle.stop()\n            }\n\n            continue\n          }\n\n          if (applyOnRequest) {\n            Object.defineProperty(accumulator, patchEntry.key, {\n              get() {\n                patch.apply()\n                return patchEntry.computed\n              },\n              enumerable: true,\n              configurable: true,\n            });\n\n            continue;\n          }\n\n\n          if (patchEntry.isAccessor) {\n            let dynName = `applyAccessorFor_${String(patchEntry.key)}`\n            let dynNameContainer = {\n              [dynName](applyTo) {\n                patchEntry.applyTo(applyTo)\n                return applyTo\n              }\n            };\n\n            accumulator[patchEntry.key] = dynNameContainer[dynName]\n          }\n          else {\n            patchEntry.applyTo(accumulator)\n          }\n        }\n\n        return accumulator\n      }, Object.create(null))\n  }\n\n  /**\n   * A getter for the custom inspect symbol used by Node.js.\n   *\n   * @returns {symbol} The custom inspect symbol.\n   */\n  static get CustomInspect() {\n    return Symbol.for('nodejs.util.inspect.custom')\n  }\n\n  /**\n   * Strips leading and trailing control characters, brackets, braces, and\n   * quotes from a string. This is typically used to clean strings that may\n   * have special characters or escape sequences that are not desired in the\n   * output.\n   *\n   * @param {string} fromString The string to be stripped of extras.\n   * @returns {string} The cleaned string with extras stripped.\n   */\n  static stripExtras(fromString) {\n    return fromString\n      .replaceAll(\n        /^(\\x1B\\[\\d+m)?[\\[\\{]\\s?|\\s?[\\]\\}](\\x1B\\[\\d+m)?$/gm,\n        '$1$2'\n      )\n      .replaceAll(\n        /['\"](.*?)['\"]/gm,\n        '$1'\n      )\n  }\n\n  /**\n   * Accessor for a Symbol uniquely representing properties that are\n   * non-enumerable but configurable. This symbol can be used to tag\n   * properties with these characteristics in a consistent manner across\n   * different parts of the application.\n   *\n   * @returns {symbol} A Symbol for properties that are non-enumerable\n   * but configurable.\n   */\n  static get kMutablyHidden() {\n    return Symbol.for('{\"enumerable\":false,\"configurable\":true}')\n  }\n\n  /**\n   * Applies a custom descriptor patch to an instance, marking properties as\n   * non-enumerable but configurable. This method utilizes the `kMutablyHidden`\n   * symbol to tag properties accordingly. It's useful for hiding properties\n   * in a way that they remain configurable for future changes.\n   *\n   * @param {object} instance The object instance to apply the patch to.\n   * @param {object} [store=Object.create(null)] An optional store object to\n   * hold patched properties' original values and descriptors.\n   * @returns {object} The result of applying the custom descriptor patch,\n   * typically a modified version of the `store` object containing the patched\n   * properties' descriptors.\n   */\n  static mutablyHidden(instance, store = Object.create(null)) {\n    return this.customDescriptorPatch(instance, this.kMutablyHidden, store);\n  }\n\n  /**\n   * Accessor for a Symbol uniquely representing properties that are both\n   * enumerable and configurable. This symbol can be used to tag properties\n   * with these characteristics in a consistent manner across different parts\n   * of the application. The symbol is created or retrieved based on a\n   * standardized JSON string, ensuring consistency in its representation.\n   *\n   * @returns {symbol} A Symbol for properties that are both enumerable and\n   * configurable, allowing them to be listed in object property enumerations\n   * and reconfigured or deleted.\n   */\n  static get kMutablyVisible() {\n    return Symbol.for('{\"enumerable\":true,\"configurable\":true}')\n  }\n\n  /**\n   * Applies a custom descriptor patch to an instance, marking properties as\n   * both enumerable and configurable. This method leverages the `kMutablyVisible`\n   * symbol to tag properties, making them visible in enumerations and allowing\n   * them to be reconfigured or deleted. This is particularly useful for\n   * properties that need to be exposed for iteration or manipulation while\n   * maintaining the ability to modify their descriptors in the future.\n   *\n   * @param {object} instance The object instance to apply the patch to.\n   * @param {object} [store=Object.create(null)] An optional store object to\n   * hold patched properties' original values and descriptors. If not provided,\n   * a new object will be used to store this information.\n   * @returns {object} The result of applying the custom descriptor patch,\n   * typically a modified version of the `store` object containing the patched\n   * properties' descriptors.\n   */\n  static mutablyVisible(instance, store = Object.create(null)) {\n    return this.customDescriptorPatch(instance, this.kMutablyVisible, store)\n  }\n\n  /**\n   * Accessor for a Symbol uniquely identifying properties that are neither\n   * enumerable nor configurable. This symbol is used to tag properties to\n   * ensure they are hidden from enumeration and cannot be reconfigured or\n   * deleted, providing a level of immutability. The symbol is generated or\n   * retrieved based on a standardized JSON string, ensuring consistency\n   * across different parts of the application.\n   *\n   * @returns {symbol} A Symbol for properties that are neither enumerable\n   * nor configurable, effectively making them immutable and hidden from\n   * property enumerations.\n   */\n  static get kImmutablyHidden() {\n    return Symbol.for('{\"enumerable\":false,\"configurable\":false}')\n  }\n\n  /**\n   * Applies a descriptor patch to an object instance, marking properties as\n   * neither enumerable nor configurable. This method uses the `kImmutablyHidden`\n   * symbol to tag properties, ensuring they remain hidden from enumerations\n   * and cannot be reconfigured or deleted. This enhances property immutability\n   * and privacy within an object. It's particularly useful for securing\n   * properties that should not be exposed or altered.\n   *\n   * @param {object} instance The object instance to apply the patch to.\n   * @param {object} [store=Object.create(null)] An optional store object to\n   * hold patched properties' original values and descriptors. If not provided,\n   * a new object will be used to store this information.\n   * @returns {object} The result of applying the descriptor patch, typically\n   * a modified version of the `store` object containing the patched properties'\n   * descriptors.\n   */\n  static immutablyHidden(instance, store = Object.create(null)) {\n    return this.customDescriptorPatch(instance, this.kImmutablyHidden, store)\n  }\n\n  /**\n   * Accessor for a Symbol uniquely identifying properties that are visible\n   * (enumerable) but not configurable. This symbol is used to tag properties\n   * to ensure they are included in enumerations such as loops and object\n   * keys retrievals, yet cannot be reconfigured or deleted. This provides a\n   * balance between visibility and immutability. The symbol is generated or\n   * retrieved based on a standardized JSON string, ensuring consistency\n   * across different parts of the application.\n   *\n   * @returns {symbol} A Symbol for properties that are enumerable but not\n   * configurable, making them visible in enumerations while preventing\n   * modifications to their descriptors.\n   */\n  static get kImmutablyVisible() {\n    return Symbol.for('{\"enumerable\":true,\"configurable\":false}')\n  }\n\n  /**\n   * Applies a descriptor patch to an object instance, marking properties as\n   * enumerable but not configurable. This method leverages the\n   * `kImmutablyVisible` symbol to tag properties, ensuring they are visible\n   * in property enumerations like loops and `Object.keys` retrievals, yet\n   * remain immutable by preventing reconfiguration or deletion. This method\n   * is particularly useful for making properties visible while maintaining\n   * their immutability and preventing modifications.\n   *\n   * @param {object} instance The object instance to apply the patch to.\n   * @param {object} [store=Object.create(null)] An optional store object to\n   * hold patched\n   * properties' original values and descriptors. If not provided, a new\n   * object will be used to store this information.\n   * @returns {object} The result of applying the descriptor patch, typically\n   * a modified version of the `store` object containing the patched properties'\n   * descriptors.\n   */\n  static immutablyVisible(instance, store = Object.create(null)) {\n    return this.customDescriptorPatch(instance, this.kImmutablyVisible, store)\n  }\n\n  /**\n   * Applies a custom descriptor patch to an object instance using a provided\n   * symbol to tag the patched properties. This method also ensures the instance\n   * is tracked for cleanup and stores the patch information in a WeakMap for\n   * future reference or rollback. It's designed to work with property\n   * descriptors that are either hidden or visible but immutable.\n   *\n   * @param {symbol} symbol The symbol used to tag the patched properties,\n   * indicating the nature of the patch (e.g., hidden or visible but immutable).\n   * @param {object} instance The object instance to which the patch is applied.\n   * @param {object} [store=Object.create(null)] An optional object to store\n   * the original property descriptors before the patch is applied. If not\n   * provided, an empty object will be used.\n   * @returns {object} The store object associated with the instance in the\n   * WeakMap, containing the patched properties' descriptors.\n   */\n  static customDescriptorPatch(instance, symbol, store = Object.create(null)) {\n    if (!this.stores.has(instance)) {\n      this.stores.set(instance, store);\n\n      if (Patch.isKnownPatchSymbol(symbol)) {\n        store[symbol] = Object.create(null);\n        return this.stores.get(instance)[symbol];\n      }\n    }\n\n    return this.stores.get(instance);\n  }\n\n  /**\n   * Determines if a given symbol is recognized as a patch symbol within the\n   * system. Patch symbols are predefined symbols used to tag properties with\n   * specific visibility and mutability characteristics. This method checks\n   * if the provided symbol matches any of the known patch symbols.\n   *\n   * @param {symbol} maybeSymbol The symbol to check against known patch symbols.\n   * @returns {boolean} True if the symbol is a known patch symbol, false otherwise.\n   */\n  static isKnownPatchSymbol(maybeSymbol) {\n    if (typeof maybeSymbol === 'symbol') {\n      return [\n        this.kImmutablyHidden,\n        this.kImmutablyVisible,\n        this.kMutablyHidden,\n        this.kMutablyVisible\n      ].some(symbol => symbol === maybeSymbol)\n    }\n\n    return false\n  }\n\n  /**\n   * Constructs an object or executes a function based on the `patchesOwner`\n   * parameter, utilizing a custom descriptor patch. This method is intended\n   * for advanced manipulation of object properties or function behaviors\n   * through patching mechanisms defined by symbols. It applies a custom\n   * descriptor patch to the `instance` using the provided `symbol` and\n   * `store`, then either returns the `patchesOwner` directly if it's not a\n   * function, or invokes it with the patched store.\n   *\n   * @param {Function|Object} patchesOwner The target function to be invoked\n   * or the object to be returned directly. If a function, it is called with\n   * the patched store.\n   * @param {Object} instance The object instance to which the patch is applied.\n   * @param {Symbol} symbol A symbol indicating the nature of the patch to be\n   * applied, typically representing specific property behaviors.\n   * @param {Object} [store=Object.create(null)] An optional object to store\n   * the original property descriptors before the patch is applied. Defaults\n   * to an empty object if not provided.\n   * @returns {Function|Object} The result of calling `patchesOwner` with the\n   * patched store if `patchesOwner` is a function, or `patchesOwner` itself\n   * if it is not a function.\n   */\n  static constructWithStore(\n    patchesOwner,\n    instance,\n    symbol,\n    store = Object.create(null)\n  ) {\n    if (typeof patchesOwner !== 'function') {\n      return patchesOwner;\n    }\n\n    try {\n      const useStore = Patch.customDescriptorPatch(instance, symbol, store);\n      return patchesOwner(useStore);\n    }\n    catch (ignored) {\n      console.error(ignored);\n      return patchesOwner;\n    }\n  }\n\n  /**\n   * Retrieves descriptor overrides from a symbol if it is recognized as a\n   * known patch symbol. This method is crucial for dynamically adjusting\n   * property descriptors based on predefined symbols, facilitating the\n   * application of specific property behaviors (e.g., visibility, mutability)\n   * without direct manipulation of the descriptors. It parses the symbol's\n   * description, which is expected to be a JSON string representing the\n   * descriptor overrides, and returns these overrides as an object.\n   *\n   * @param {symbol} symbol The symbol whose description contains JSON\n   * stringified descriptor overrides.\n   * @returns {object} An object representing the descriptor overrides if the\n   * symbol is recognized; otherwise, an empty object.\n   */\n  static getDescriptorOverridesFromSymbol(symbol) {\n    let overrides = Object.create(null)\n\n    if (this.isKnownPatchSymbol(symbol)) {\n      overrides = JSON.parse(symbol.description)\n    }\n\n    return overrides;\n  }\n\n  /**\n   * A WeakMap to store patch information for object instances. This map\n   * associates each patched object instance with its corresponding store\n   * object, which contains the original property descriptors before the\n   * patch was applied. The use of a WeakMap ensures that the memory used\n   * to store this information can be reclaimed once the object instances\n   * are no longer in use, preventing memory leaks.\n   */\n  static stores = new WeakMap();\n\n  /**\n   * Creates and returns an object that wraps a string with additional\n   * properties and methods, making it more informative and useful for\n   * debugging purposes. This method enhances a string by associating it\n   * with a key-value pair and providing custom inspection functionality\n   * for Node.js environments.\n   *\n   * @param {string} string The base string to be wrapped and enhanced.\n   * @param {string} key The key associated with the string, accessible via the\n   * `key` property of the returned object.\n   * @param {any} value The value associated with the key, accessible via the\n   * `value` property of the returned object.\n   * @returns {object} An object that wraps the original string and includes\n   * additional properties (`key`, `value`, `entry`, `entries`) and methods\n   * (`valueOf`, custom inspection method for Node.js) for enhanced usability\n   * and debugging.\n   */\n  static stringRef(string, key, value) {\n    const stringObj = Object.assign(Object(string), {\n      get key() { return key },\n      get value() { return value },\n      get entry() { return [key, value] },\n      get entries() { return [this.entry] },\n      valueOf() { return String(this) },\n      [Symbol.toStringTag]: 'String',\n      [Symbol.for('nodejs.util.inspect.custom')](_, __, inspect) {\n        return inspect(String(this), { colors: true })\n      }\n    });\n\n    return stringObj\n  }\n\n  /**\n   * Checks if all own property names of an instance are also present as own\n   * property names in a given prototype or the instance's constructor\n   * prototype. This method is useful for determining if an instance shares\n   * all its own property names with a prototype, which can be helpful in\n   * various forms of type or structure validation.\n   *\n   * @param {object} instance The object instance whose own property names are\n   * to be checked.\n   * @param {object} [prototype] The prototype object to compare against. If not\n   * provided, the method uses the instance's constructor prototype.\n   * @returns {boolean} Returns true if all own property names of the instance\n   * are also own property names in the given prototype or the instance's\n   * constructor prototype. Otherwise, returns false.\n   */\n  static shareOwnPropertyNames(instance, prototype) {\n    const ownPropNames = o => Object.getOwnPropertyNames(Object(o))\n\n    return ownPropNames(instance).every(key =>\n      ownPropNames(prototype ?? instance?.constructor?.prototype).\n      some(innerKey => innerKey == key)\n    )\n  }\n\n\n  /**\n   * Extracts a descriptive name for a given object or function. This method\n   * attempts to identify the most appropriate name based on the object's\n   * characteristics or its constructor's name. If no specific name can be\n   * determined, it falls back to a provided default name or generates a\n   * unique identifier.\n   *\n   * The method first checks if the object is a non-function or an exception\n   * like `Function.prototype`, and if it shares all the same own property\n   * names as its constructor's prototype, it returns the constructor's name\n   * with `.prototype` appended. If this check fails, it looks for a\n   * `Symbol.toStringTag` property, then for a function's `name` property,\n   * and then evaluates `defaultName` if it's a function or uses its string\n   * value. If all these checks fail, it looks for known exceptions like\n   * `Reflect` or generates a random string prefixed with `Unknown.`.\n   *\n   * @param {object|function} object The object or function to extract the name\n   * from.\n   * @param {string|function} defaultName A default name or a function that\n   * returns a default name to use if no specific name can be determined.\n   * @returns {string} The extracted name or the default/fallback name.\n   */\n  static extractName(object, defaultName) {\n    // Short-hand helper for Array.some(k => k === value)\n    const oneOf = (a,type) => a.some(value => value === type)\n\n    // Initially set valueOf to undefined\n    let valueOf = undefined\n\n    // Skipping known exceptions, check to see if the valueOf() exists\n    if (!oneOf([Symbol.prototype, Date.prototype, BigInt.prototype], object)) {\n      valueOf = object?.valueOf?.()\n    }\n\n    // Check to see if the result from valueOf() is a String\n    let valueOfAsString = (\n      (valueOf && (valueOf instanceof String || typeof valueOf === 'string'))\n        ? String(valueOf)\n        : undefined\n    )\n\n    return (\n      // If its a symbol, use its String() value\n      (typeof object === 'symbol' ? String(object) : undefined) ??\n      (typeof object === 'string' ? object : undefined) ??\n      (object instanceof String ? String(object) : undefined)\n    ) || (\n      // If we have a non-function (Function.prototype is the exception)\n      // and we do have a constructor property, we share all the same\n      // ownPropertyNames as the constructor's prototype (string instances\n      // do not have the same props for example) then we can probably\n      // assume we have a class/function prototype so return its name plus\n      // .prototype\n      (\n        (object === Function.prototype || typeof object !== 'function') &&\n        typeof object !== 'symbol'\n      ) &&\n      Patch.shareOwnPropertyNames(object) &&\n      object?.constructor?.name &&\n      `${object.constructor.name}.prototype`\n    ) || (\n      // Look for a Symbol.toStringTag first as this denotes a specified name\n      object?.[Symbol.toStringTag] ??\n\n      // Look for a function instance .name property next\n      object?.name ??\n\n      // Look for object.valueOf() and see if its a string\n      valueOfAsString ??\n\n      // If defaultName is a function, use its return value\n      (typeof defaultName === 'function' ? defaultName(object) : undefined) ??\n\n      // If defaultName is a string, use its value\n      (typeof defaultName === 'string' ? defaultName : undefined) ??\n\n      // Check for rare exceptions like Reflect (add more here as found)\n      Object.entries({\n        Reflect\n      }).find(([k,v]) => v === object)?.[0] ??\n\n      // Finally generate an Unknown.{randomString} value if nothing else works\n      `Unknown.${Math.random().toString(36).slice(2)}`\n    )\n  }\n}\n\n/**\n * Custom inspection function for Node.js `util.inspect` that formats the\n * entries of the Patch.patches Map for improved readability in console output.\n * This function is specifically designed to be used as a custom inspection\n * function within Node.js environments, enhancing the debugging experience\n * by providing a clear, formatted view of the Patch.patches Map's entries.\n *\n * @param {number} depth The depth to which the object should be formatted.\n * @param {object} options Formatting options provided by `util.inspect`.\n * @param {function} inspect The inspection function provided by Node.js\n * `util.inspect`, allowing for custom formatting of nested properties.\n * @returns {string} A formatted string representation of the Patch.patches\n * Map's entries, with each key-value pair on a new line and keys highlighted\n * for easy identification.\n */\nPatch.patches[Symbol.for('nodejs.util.inspect.custom')] = function(\n  depth,\n  options,\n  inspect\n) {\n  let parts = [\n    'Patches [',\n    ([...this.entries()]\n      .map(([key, value]) =>\n        `\\x1b[22;1m${Patch.extractName(key)}\\x1b[22m =>` +\n        `${\n          inspect(value, options)\n            .trim()\n            .replaceAll(/^\\s*\\[/g, '')\n            .replaceAll(/\\s*\\]$/g, '')\n        }\\n`\n      )\n      .toSorted()\n      .join('\\n')\n    ),\n    ']'\n  ];\n\n  if (parts[1].includes('\\n')) {\n    // Indent each line of the body by two spaces\n    parts[1] = parts[1].split('\\n').map(line => {\n      let newLine = `  ${line}`;\n      return (/(?:=>[^\\n]\\w)/.exec(newLine)\n        ? newLine.replace(/(=>)/, '=>\\n    ')\n        : newLine\n      )\n    }).join('\\n');\n\n    // Join the output with new lines surrounding the body\n    let output = parts.join('\\n');\n    return output.replace(/\\n\\s*\\n]$/m, '\\n]');\n  }\n\n  if (!parts[1]) {\n    parts[1] = '\\x1b[2;3mNo patches or extensions yet\\x1b[22;23m'\n  }\n\n  return parts.join('');\n}", "import { CannotBeExtendedError } from \"./errors/CannotBeExtendedError.js\"\nimport { MissingOwnerValue } from './errors/MissingOwnerValue.js'\nimport { Patch } from './patch.js'\n\n/** Shared array of primitive types for use with `isPrimitive` */\nconst primitives = ['number', 'boolean', 'bigint', 'string', 'symbol']\n\n/**\n * The Extension class, inheriting from the Patch class, is specifically designed\n * for extending properties or methods of a given object. It facilitates the\n * extension process by determining the target key and value for the extension and\n * ensuring the target property is writable and configurable. If these conditions\n * are not met, the class throws a CannotBeExtendedError. This class is useful\n * in scenarios like testing, dynamic behavior adjustments, or managing complex\n * object configurations.\n */\nexport class Extension extends Patch {\n  /**\n   * Constructs a new Extension instance. This constructor initializes the extension\n   * by determining the target key and value for the extension and ensuring that\n   * the property to be extended is configurable and writable. It throws an error\n   * if these conditions are not satisfied. The constructor leverages the Patch\n   * class's functionalities to manage the extension effectively.\n   *\n   * @param {Function|string} keyClassOrFn - The key, class, or function to be\n   * used for the extension. If a function or class is provided, its name is used\n   * as the key.\n   * @param {*} value - The value or method to be used for the extension.\n   * @param {object} [owner=globalThis] - The object to which the extension will\n   * be applied.\n   * @param {object} [options={}] - Additional options for the extension behavior.\n   * @throws {CannotBeExtendedError} If the target property is not writable or\n   * configurable.\n   * @throws {MissingOwnerValue} If the `keyClassOrFn` value is null or there\n   * is an error determining the key and extension values, MissingOwnerValue is\n   * thrown.\n   */\n  constructor(keyClassOrFn, value, owner = globalThis, options = {}) {\n    const metadata = Extension.determineInput(keyClassOrFn)\n    let { key, extension, valid } = metadata\n    extension = value || extension\n\n    if (!valid) {\n      throw new MissingOwnerValue(owner, key)\n    }\n\n    const descriptor = Object.getOwnPropertyDescriptor(owner, key)\n    if (descriptor) {\n      if (\n        (Reflect.has(descriptor, 'writable') && !descriptor.writable) ||\n        (Reflect.has(descriptor, 'configurable') && !descriptor.configurable)\n      ) {\n        throw new CannotBeExtendedError(owner, key)\n      }\n    }\n\n    super(owner, { [key]: extension }, options)\n    this.key = key\n\n    this.class = metadata.class\n    this.function = metadata.function\n  }\n\n  /**\n   * Returns true if this `Extension` represents a `function`\n   *\n   * @returns {boolean} `true` if this `Extension` introduces a `function`, or\n   * `false` if it does not\n   */\n  get isFunction() { return !!(this.function) }\n\n  /**\n   * Returns true if this `Extension` represents a `class`\n   *\n   * @returns {boolean} `true` if this `Extension` introduces a `class`, or\n   * `false` if it does not\n   */\n  get isClass() { return !!(this.class) }\n\n  /**\n   * Returns true if this `Extension` represents a `primitive`\n   *\n   * @returns {boolean} `true` if this `Extension` introduces a\n   * primitive value or `false` if it does not.\n   */\n  get isPrimitive() {\n    return ~primitives.indexOf(typeof this.value)\n  }\n\n  /**\n   * Returns true if this `Extension` represents a value that is not\n   * coerced into an `Object` wrapper when wrapped with `Object(value)`\n   *\n   * @returns {boolean} `true` if this `Extension` introduces a value\n   * that is alrady an `object`, `false` otherwise.\n   */\n  get isObject() {\n    return Object(this.value) === this.value\n  }\n\n  /**\n   * A static getter that provides a proxy to manage and interact with the\n   * patches that have been applied globally. This proxy abstracts the\n   * underlying details and presents a simplified interface for querying and\n   * manipulating applied patches. It is particularly useful in IDEs, as it\n   * allows developers to access the state of applied patches without needing\n   * to delve into the source code.\n   *\n   * @returns {Object} An object showing all the keys known to be patched for\n   * the default owner, `globalThis`\n   */\n  static get applied() {\n    return Patch.applied;\n  }\n\n  /**\n   * A static getter that provides access to a proxy representing all known\n   * patches, whether applied or not. This is useful for inspecting the\n   * complete set of patches that have been registered in the system, without\n   * limiting the view to only those that are currently active. The proxy\n   * abstracts the underlying details and presents a simplified interface for\n   * querying and manipulating the patches.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of all\n   * registered patches, allowing for operations like checking if a patch is\n   * known and retrieving patch values.\n   */\n  static get known() {\n    return Patch.known;\n  }\n\n  /**\n   * A static getter that provides access to a proxy for managing patch\n   * entries with a toggle functionality. This proxy allows the temporary\n   * application of patches within a certain scope, and automatically reverts\n   * them after the scope ends. It is useful for applying patches in a\n   * controlled manner, ensuring that they do not remain active beyond the\n   * intended usage.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of the\n   * patches with toggle functionality, allowing for temporary application\n   * and automatic reversion of patches.\n   */\n  static get use() {\n    return Patch.use;\n  }\n\n  /**\n   * A static getter that provides access to a proxy for managing patch\n   * entries with lazy initialization. This proxy defers the creation and\n   * application of patches until they are explicitly requested. It is\n   * beneficial for performance optimization, as it avoids the overhead of\n   * initializing patches that may not be used.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of the\n   * patches with lazy initialization, allowing patches to be created and\n   * applied only when needed.\n   */\n  static get lazy() {\n    return Patch.lazy;\n  }\n\n\n  /**\n   * Returns an object with getters to access different proxy views of patches\n   * scoped to a specific owner. This allows for interaction with patches\n   * that are either applied, known, or used within a certain scope, providing\n   * a controlled environment for patch management.\n   *\n   * @param {object} owner - The object to scope the patch proxies to.\n   * @returns {object} An object containing getters for `applied`, `known`,\n   * and `use` proxies:\n   * - `applied`: Proxy for patches applied to the owner.\n   * - `known`: Proxy for all patches known to the owner, applied or not.\n   * - `use`: Proxy that allows temporary application of patches.\n   */\n  static scopedTo(owner) {\n    return Patch.scopedTo(owner);\n  }\n\n  /**\n   * Determines the input type for the extension. This method processes the input\n   * and identifies the key for the extension and the associated value or method.\n   * It supports inputs as either a string key or a function/class, providing\n   * flexibility in defining extensions.\n   *\n   * @param {Function|string} keyClassOrFn - The key, class, or function provided\n   * as input. If a function or class is provided, its name is used as the key.\n   * containing the determined key, the extension value/method, and a validity flag\n   * indicating whether the input is usable.\n   * @returns {{key: string|null, extension: *|null, valid: boolean}} An object\n   */\n  static determineInput(keyClassOrFn) {\n    let input = { key: null, extension: null, valid: false }\n\n    if (keyClassOrFn instanceof Function) {\n      input = {\n        key: keyClassOrFn.name,\n        extension: keyClassOrFn,\n        valid: true\n      }\n\n      if (/^class .*/.exec(keyClassOrFn.toString())) {\n        input.class = keyClassOrFn\n      }\n\n      if (/^(async )?function .*/.exec(keyClassOrFn.toString())) {\n        input.function = keyClassOrFn\n      }\n    }\n    else if (typeof keyClassOrFn === 'string' || keyClassOrFn instanceof String) {\n      input = { key: keyClassOrFn, extension: null, valid: true }\n    }\n\n    return input\n  }\n\n  /**\n   * Custom inspect function for Node.js that provides a formatted representation\n   * of the Extension instance, primarily for debugging purposes.\n   *\n   * @param {number} depth The depth to which the object should be formatted.\n   * @param {object} options Formatting options.\n   * @param {function} inspect The inspection function to format the object.\n   * @returns {string} A formatted string representing the Extension instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const exprs = {\n      get braces() { return /^(\\x1B\\[\\d+m)?[\\[\\{]|[\\]\\}](\\x1B\\[\\d+m)?$/g },\n    }\n\n    const val =\n      inspect(this.patches[this.key], options).replaceAll(exprs.braces, '$1$2')\n\n    return `Extension[${val}]`\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Provides the class name when the\n   * object is converted to a string, typically used for debugging and logging.\n   *\n   * @returns {string} The class name of the Extension instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Creates a new ExtensionSet with the provided name and extensions.\n   *\n   * @param {string} name - The name of the extension set.\n   * @param {...Extension|Function} extensions - A list of extensions or\n   * functions to include in the set.\n   * @returns {ExtensionSet} A new instance of ExtensionSet containing the\n   * given extensions.\n   */\n  static createSet(name, ...extensions) {\n    return new Extension.ExtensionSet(name, ...extensions)\n  }\n\n  /**\n   * Represents a set of extensions.\n   */\n  static ExtensionSet = class ExtensionSet {\n    /**\n     * Creates an instance of ExtensionSet.\n     *\n     * @param {string} name - The name of the extension set.\n     * @param {...(Extension|Function)} extensions - Extensions or functions to\n     * add to the set.\n     */\n    constructor(name, ...extensions) {\n      this.name = name;\n      this.extensionObjects = new Set();\n      this.extensions = new Set();\n\n      for (const extensionValue of extensions) {\n        if (extensionValue instanceof Extension) {\n          this.extensions.add(extensionValue);\n          this.extensionObjects.add(extensionValue.patches[extensionValue.key]);\n        } else if (extensionValue instanceof Function) {\n          this.extensionObjects.add(extensionValue);\n          this.extensions.add(new Extension(extensionValue));\n        }\n      }\n    }\n\n    /**\n     * Applies all extensions in the set.\n     */\n    apply() {\n      for (const extension of this.extensions) {\n        extension.apply();\n      }\n    }\n\n    /**\n     * Reverts all extensions in the set.\n     */\n    revert() {\n      for (const extension of this.extensions) {\n        extension.revert();\n      }\n    }\n  }\n}"],
  "mappings": "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",
  "names": ["src_exports", "__export", "Errors", "Extension", "Patch", "PatchEntry", "PatchToggle", "typeOf", "o", "CannotBeExtendedError", "owner", "key", "typeOf", "o", "MissingOwnerValue", "owner", "key", "PatchToggle", "patch", "preventRevert", "depth", "options", "inspect", "objName", "status", "PatchEntry", "property", "owningObject", "condition", "descriptorOverrides", "isNullish", "value", "isKey", "types", "f", "isObject", "descriptor", "anotherObject", "bindAccessors", "depth", "options", "inspect", "name", "type", "writable", "Patch", "_Patch", "owner", "patches", "options", "patchesOwner", "overrides", "globalCondition", "key", "condition", "useOverrides", "useOwner", "PatchEntry", "error", "acc", "patchEntry", "_", "prettyEntries", "value", "pe", "metrics", "entries", "counts", "patch", "oDesc", "#equalDescriptors", "preventRevert", "PatchToggle", "conflicts", "appliedDescriptor", "left", "right", "depth", "inspect", "type", "name", "keys", "entry", "#allPatchesForOwner", "allForOwner", "appliedOnly", "wrapInToggle", "applyOnRequest", "onlyApplied", "accumulator", "usage", "toggle", "dynName", "dynNameContainer", "applyTo", "fromString", "instance", "store", "symbol", "maybeSymbol", "useStore", "ignored", "string", "__", "prototype", "ownPropNames", "o", "innerKey", "object", "defaultName", "oneOf", "a", "valueOf", "valueOfAsString", "k", "v", "parts", "line", "newLine", "primitives", "Extension", "_Extension", "Patch", "keyClassOrFn", "value", "owner", "options", "metadata", "key", "extension", "valid", "MissingOwnerValue", "descriptor", "CannotBeExtendedError", "input", "depth", "inspect", "exprs", "name", "extensions", "extensionValue", "Errors", "CannotBeExtendedError", "MissingOwnerValue"]
}
