var nejsExtension=(()=>{var m=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var w=Object.prototype.hasOwnProperty;var v=(o,t)=>{for(var e in t)m(o,e,{get:t[e],enumerable:!0})},x=(o,t,e,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of b(t))!w.call(o,i)&&i!==e&&m(o,i,{get:()=>t[i],enumerable:!(s=y(t,i))||s.enumerable});return o};var A=o=>x(m({},"__esModule",{value:!0}),o);var j={};v(j,{Errors:()=>P,Extension:()=>f,Patch:()=>d,PatchEntry:()=>p,PatchToggle:()=>u});var E=o=>/(\w+)]/.exec(Object.prototype.toString.call(o))[1],l=class extends Error{constructor(t,e){super(`${E(t)} disallows tampering with ${e}.`),Object.assign(this,{owner:t,key:e})}get[Symbol.toStringTag](){return this.constructor.name}};var $=o=>/(\w+)]/.exec(Object.prototype.toString.call(o))[1],h=class extends Error{constructor(t,e){super(`${$(t)} does not have a property named '${e}'.`),Object.assign(this,{owner:t,key:e})}get[Symbol.toStringTag](){return this.constructor.name}};var u=class{constructor(t,e=!1){this.started=!1,this.preventRevert=e,this.patch=t,this.patchName=t.owner?.name??t.owner?.constructor?.name??/(\w+)]/.exec(Object.prototype.toString.call(t.owner))[1],this.state={needsApplication:!1,needsReversion:!1}}start(){return this.started||(this.state.needsApplication=!this.patch.applied,this.state.needsReversion=this.patch.applied,this.started=!0,this.state.needsApplication&&this.patch.apply()),this}stop(){return this.started&&((this.preventRevert||this.patch.applied)&&this.patch.revert(),this.state.needsApplication=!1,this.state.needsReversion=!1,this.started=!1),this}get[Symbol.toStringTag](){return`${this.constructor.name}:${this.patchName}`}[Symbol.for("nodejs.util.inspect.custom")](t,e,s){let i=this[Symbol.toStringTag],r=`(started: ${this.started} needed: ${this.state.needsApplication})`;return s(`${i} ${r}`,{...e,depth:t})}};var p=class{constructor(t,e=globalThis,s=void 0){let i=n=>n==null,r=(n,g=["string","symbol"])=>!i(n)&&!!g.find(a=>a===typeof n),c=n=>r(n,["object"]);if(!r(t))throw console.error("Property",t,`(type: ${typeof t})`,"owningObject",e,`(type: ${typeof e})`,"condition",s,`(type: ${typeof s})`),new TypeError("Property must be non-null and either a string or symbol");if(!c(e))throw new TypeError("Cannot create Patch entry as owning object is invalid");Object.assign(this,{key:t,descriptor:Object.getOwnPropertyDescriptor(e,t),owner:e,condition:typeof s=="function"?s:void 0})}get computed(){return this.isAccessor?this.descriptor.get.bind(this.owner).call():this.descriptor.value}get isData(){return Reflect.has(this.descriptor,"value")}get isAccessor(){return Reflect.has(this.descriptor,"get")}get isReadOnly(){return Reflect.has(this.descriptor,"configurable")&&!this.descriptor.configurable||Reflect.has(this.descriptor,"writable")&&!this.descriptor.writable}get isAllowed(){return this.condition&&typeof this.condition=="function"?this.condition():!0}get[Symbol.toStringTag](){return this.constructor.name}[Symbol.for("nodejs.util.inspect.custom")](t,e,s){let i=this.isData?" Data":" Accessor",r=this.isReadOnly?" [ReadOnly]":"";return`PatchEntry<${this.key}${i}${r}>`}};var d=class o{constructor(t,e,s={}){Object.assign(this,{owner:t,options:s}),this.patchConflicts={},this.patchEntries={},this.patchesOwner=e,this.patchCount=0,this.patchesApplied=0;let i=this?.options.condition;Reflect.ownKeys(e).forEach(r=>{let c=this?.options?.conditions?.[r]??i;try{this.patchEntries[r]=new p(r,this.patchesOwner,c),this.patchCount+=1}catch(n){console.error(`Failed to process patch for ${r}
`,n)}if(Reflect.has(this.owner,r))try{this.patchConflicts[r]=new p(r,this.owner)}catch(n){console.error(`Cannot capture conflicting patch key ${r}
`,n)}}),o.patches.has(t)||o.patches.set(t,[]),o.patches.get(t).push(this)}get entries(){return Reflect.ownKeys(this.patchEntries).map(t=>[t,this.patchEntries[t]])}get patches(){return this.entries.reduce((t,[e,s])=>(t[e]=s.computed,t),{})}get conflicts(){return Reflect.ownKeys(this.patchConflicts).map(t=>[t,this.patchConflicts[t]])}get applied(){return this.patchesApplied>0}get isPartiallyPatched(){return this.applied}get isFullyPatched(){return this.patchCount==this.patchesApplied}apply(t){let e=this.entries,s={patches:e.length,applied:0,errors:[],notApplied:e.length};e.forEach(([,i])=>{if(i.isAllowed){Object.defineProperty(this.owner,i.key,i.descriptor);let r=Object.getOwnPropertyDescriptor(this.owner,i.key);this.#t(r,i.descriptor)?(s.applied+=1,s.notApplied-=1):s.errors.push([i,new Error(`Could not apply patch for key ${i.key}`)])}}),this.patchesApplied=s.applied,typeof t=="function"&&t(s)}createToggle(t=!1){return new u(this,t)}revert(t){if(!this.applied)return;let e=this.entries,s=this.conflicts,i={patches:e.length,reverted:0,restored:0,conflicts:s.length,errors:[],stillApplied:0};e.forEach(([,r])=>{delete this.owner[r.key]?(this.patchesApplied-=1,i.reverted+=1):i.errors.push([r,new Error(`Failed to revert patch ${r.key}`)])}),s.forEach(([,r])=>{Object.defineProperty(this.owner,r.key,r.descriptor);let c=Object.getOwnPropertyDescriptor(this.owner,r.key);this.#t(r.descriptor,c)?i.restored+=1:i.errors.push([r,new Error(`Failed to restore original ${r.key}`)])}),i.stillApplied=this.patchesApplied,typeof t=="function"&&t(i)}release(){let t=o.patches.get(this.owner);t.splice(t.find(e=>e===this),1)}owner=null;options=null;#t(t,e){if(!t||!e)return!1;let s=!0;return s=s&&t.configurable===e.configurable,s=s&&t.enumerable===e.enumerable,s=s&&t.value===e.value,s=s&&t.writable===e.writable,s=s&&t.get===e.get,s=s&&t.set===e.set,s}static patches=new Map;static enableFor(t){if(o.patches.has(t))for(let e of o.patches.get(t))e.apply()}static disableFor(t){if(o.patches.has(t))for(let e of o.patches.get(t))e.revert()}};var S=["number","boolean","bigint","string","symbol"],f=class o extends d{constructor(t,e,s=globalThis,i={}){let r=o.determineInput(t),{key:c,extension:n,valid:g}=r;if(n=e||n,!g)throw new h(s,c);let a=Object.getOwnPropertyDescriptor(s,c);if(a&&(Reflect.has(a,"writable")&&!a.writable||Reflect.has(a,"configurable")&&!a.configurable))throw new l(s,c);super(s,{[c]:n},i),this.key=c,this.class=r.class,this.function=r.function}get isFunction(){return!!this.function}get isClass(){return!!this.class}get isPrimitive(){return~S.indexOf(typeof this.value)}get isObject(){return Object(this.value)===this.value}static determineInput(t){let e={key:null,extension:null,valid:!1};return t instanceof Function?(e={key:t.name,extension:t,valid:!0},/^class .*/.exec(t.toString())&&(e.class=t),/^(async )?function .*/.exec(t.toString())&&(e.function=t)):(typeof t=="string"||t instanceof String)&&(e={key:t,extension:null,valid:!0}),e}[Symbol.for("nodejs.util.inspect.custom")](t,e,s){return`Extension<${this.key}>`}get[Symbol.toStringTag](){return this.constructor.name}};var P={get CannotBeExtended(){return l},get MissingOwnerValue(){return h}};return A(j);})();
//# sourceMappingURL=extension.bundle.2.1.0.js.map
