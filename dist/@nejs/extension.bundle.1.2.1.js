var nejsExtension=(()=>{var u=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var b=Object.prototype.hasOwnProperty;var y=(s,t)=>{for(var e in t)u(s,e,{get:t[e],enumerable:!0})},w=(s,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of m(t))!b.call(s,i)&&i!==e&&u(s,i,{get:()=>t[i],enumerable:!(r=g(t,i))||r.enumerable});return s};var x=s=>w(u({},"__esModule",{value:!0}),s);var E={};y(E,{Errors:()=>v,Extension:()=>l,Patch:()=>h,PatchToggle:()=>c});var S=s=>/(\w+)]/.exec(Object.prototype.toString.call(s))[1],n=class extends Error{constructor(t,e){super(`${S(t)} disallows tampering with ${e}.`),Object.assign(this,{owner:t,key:e})}get[Symbol.toStringTag](){return this.constructor.name}};var R=s=>/(\w+)]/.exec(Object.prototype.toString.call(s))[1],a=class extends Error{constructor(t,e){super(`${R(t)} does not have a property named '${e}'.`),Object.assign(this,{owner:t,key:e})}get[Symbol.toStringTag](){return this.constructor.name}};var c=class{constructor(t,e=!1){this.started=!1,this.preventRevert=e,this.patch=t,this.patchName=t.owner?.name??t.owner?.constructor?.name??/(\w+)]/.exec(Object.prototype.toString.call(t.owner))[1],this.state={needsApplication:!1,needsReversion:!1}}start(){return this.started||(this.state.needsApplication=!this.patch.applied,this.state.needsReversion=this.patch.applied,this.started=!0,this.state.needsApplication&&this.patch.apply()),this}stop(){return this.started&&((this.preventRevert||this.patch.applied)&&this.patch.revert(),this.state.needsApplication=!1,this.state.needsReversion=!1,this.started=!1),this}get[Symbol.toStringTag](){return`${this.constructor.name}:${this.patchName}`}[Symbol.for("nodejs.util.inspect.custom")](t,e,r){let i=this[Symbol.toStringTag],o=`(started: ${this.started} needed: ${this.state.needsApplication})`;return r(`${i} ${o}`,{...e,depth:t})}};var h=class s{constructor(t,e,r={}){Object.assign(this,{owner:t,options:r,applied:!1}),this.patchConflicts={},this.patchEntries={},this.patchesOwner=e,Reflect.ownKeys(e).forEach(i=>{this.patchEntries[i]=new s.#t(i,this.patchesOwner),Reflect.has(this.owner,i)&&(this.patchConflicts[i]=new s.#t(i,this.owner))}),s.patches.has(t)||s.patches.set(t,[]),s.patches.get(t).push(this)}get patches(){return Reflect.ownKeys(this.patchEntries).map(t=>[t,this.patchEntries[t]])}get patchValues(){return this.patches.reduce((t,[e,r])=>(t[e]=r.computed,t),{})}get conflicts(){return Reflect.ownKeys(this.patchConflicts).map(t=>[t,this.patchConflicts[t]])}apply(){this.applied||(this.patches.forEach(([,t])=>{Object.defineProperty(this.owner,t.key,t.descriptor)}),this.applied=!0)}createToggle(t=!1){return new c(this,t)}revert(){this.applied&&(this.patches.forEach(([,t])=>{delete this.owner[t.key]}),this.conflicts.forEach(([,t])=>{Object.defineProperty(this.owner,t.key,t.descriptor)}),this.applied=!1)}release(){let t=s.patches.get(this.owner);t.splice(t.find(e=>e===this),1)}owner=null;options=null;static patches=new Map;static enableFor(t){if(s.patches.has(t))for(let e of s.patches.get(t))e.apply()}static disableFor(t){if(s.patches.has(t))for(let e of s.patches.get(t))e.revert()}static#t=class{constructor(t,e=globalThis){Object.assign(this,{key:t,descriptor:Object.getOwnPropertyDescriptor(e,t),owner:e})}get computed(){return this.isAccessor?this.descriptor.get.bind(this.owner).call():this.descriptor.value}get isData(){return Reflect.has(this.descriptor,"value")}get isAccessor(){return Reflect.has(this.descriptor,"get")}get isReadOnly(){return Reflect.has(this.descriptor,"configurable")&&!this.descriptor.configurable||Reflect.has(this.descriptor,"writable")&&!this.descriptor.writable}get[Symbol.toStringTag](){return this.constructor.name}[Symbol.for("nodejs.util.inspect.custom")](t,e,r){return`PatchEntry<${this.key}, ${this.isData?"Data":"Accessor"}${this.isReadOnly?" [ReadOnly]":""}>`}}};var l=class s extends h{constructor(t,e,r=globalThis,i={}){let{key:o,extension:f,valid:d}=s.determineInput(t);if(f=e||f,!d)throw new a(r,o);let p=Object.getOwnPropertyDescriptor(r,o);if(p&&(Reflect.has(p,"writable")&&!p.writable||Reflect.has(p,"configurable")&&!p.configurable))throw new n(r,o);super(r,{[o]:f},i),this.key=o}static determineInput(t){let e={key:null,extension:null,valid:!1};return t instanceof Function?e={key:t.name,extension:t,valid:!0}:(typeof t=="string"||t instanceof String)&&(e={key:t,extension:null,valid:!0}),e}[Symbol.for("nodejs.util.inspect.custom")](t,e,r){return`Extension<${this.key}>`}get[Symbol.toStringTag](){return this.constructor.name}};var v={get CannotBeExtended(){return n},get MissingOwnerValue(){return a}};return x(E);})();
//# sourceMappingURL=extension.bundle.1.2.1.js.map
