var nejsExtension=(()=>{var m=Object.defineProperty;var S=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var x=Object.prototype.hasOwnProperty;var j=(i,t)=>{for(var e in t)m(i,e,{get:t[e],enumerable:!0})},O=(i,t,e,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of w(t))!x.call(i,r)&&r!==e&&m(i,r,{get:()=>t[r],enumerable:!(s=S(t,r))||s.enumerable});return i};var $=i=>O(m({},"__esModule",{value:!0}),i);var T={};j(T,{Errors:()=>A,Extension:()=>g,Patch:()=>u,PatchEntry:()=>h,PatchToggle:()=>b});var P=i=>/(\w+)]/.exec(Object.prototype.toString.call(i))[1],f=class extends Error{constructor(t,e){super(`${P(t)} disallows tampering with ${e}.`),Object.assign(this,{owner:t,key:e})}get[Symbol.toStringTag](){return this.constructor.name}};var E=i=>/(\w+)]/.exec(Object.prototype.toString.call(i))[1],d=class extends Error{constructor(t,e){super(`${E(t)} does not have a property named '${e}'.`),Object.assign(this,{owner:t,key:e})}get[Symbol.toStringTag](){return this.constructor.name}};var b=class{constructor(t,e=!1){this.started=!1,this.preventRevert=e,this.patch=t,this.patchName=t.owner?.name??t.owner?.constructor?.name??/(\w+)]/.exec(Object.prototype.toString.call(t.owner))[1],this.state={needsApplication:!1,needsReversion:!1}}start(){return this.started||(this.state.needsApplication=!this.patch.applied,this.state.needsReversion=this.patch.applied,this.started=!0,this.state.needsApplication&&this.patch.apply()),this}stop(){return this.started&&((this.preventRevert||this.patch.applied)&&this.patch.revert(),this.state.needsApplication=!1,this.state.needsReversion=!1,this.started=!1),this}get[Symbol.toStringTag](){return`${this.constructor.name}:${this.patchName}`}[Symbol.for("nodejs.util.inspect.custom")](t,e,s){let r=this[Symbol.toStringTag],n=`(started: ${this.started} needed: ${this.state.needsApplication})`;return s(`${r} ${n}`,{...e,depth:t})}};var h=class{constructor(t,e=globalThis,s=void 0,r={}){let n=c=>c==null,o=(c,p=["string","symbol"])=>!n(c)&&!!p.find(y=>y===typeof c),a=c=>o(c,["object"]);if(!o(t))throw console.error("Property",t,`(type: ${typeof t})`,"owningObject",e,`(type: ${typeof e})`,"condition",s,`(type: ${typeof s})`),new TypeError("Property must be non-null and either a string or symbol");if(!a(e))throw new TypeError("Cannot create Patch entry as owning object is invalid");let l={...Object.getOwnPropertyDescriptor(e,t),...Object(r)};Object.assign(this,{key:t,descriptor:l,owner:e,condition:typeof s=="function"?s:void 0})}get computed(){return this.isAccessor?this.descriptor.get.bind(this.owner).call():this.descriptor.value}get isData(){return Reflect.has(this.descriptor,"value")}get isAccessor(){return Reflect.has(this.descriptor,"get")}get isReadOnly(){return Reflect.has(this.descriptor,"configurable")&&!this.descriptor.configurable||Reflect.has(this.descriptor,"writable")&&!this.descriptor.writable}get isAllowed(){return this.condition&&typeof this.condition=="function"?this.condition():!0}applyTo(t,e=!1){let s={...this.descriptor};e&&(typeof s.get=="function"&&(s.get=s.get.bind(this.owner)),typeof s.set=="function"&&(s.set=s.set.bind(this.owner))),Object.defineProperty(t,this.key,s)}get[Symbol.toStringTag](){return this.constructor.name}[Symbol.for("nodejs.util.inspect.custom")](t,e,s){let r=`\x1B[33m${this.key}\x1B[39m`,n=this.isData?" Data":" Accessor",o=this.isReadOnly?" [\x1B[2;3mReadOnly\x1B[22;23m]":"";return`PatchEntry<${r}${n}${o}>`}};var u=class i{patchConflicts=Object.create(null);patchEntries=Object.create(null);patchesOwner=void 0;patchCount=0;patchesApplied=0;ownerDisplayName=void 0;constructor(t,e,s=Object.create(null)){Object.assign(this,{owner:t,options:s}),this.ownerDisplayName=s?.displayName,s?.displayName||(this.ownerDisplayName=t?.name??t?.[Symbol.toStringTag]),this.patchesOwner=i.constructWithStore(e,this),this.generatePatchEntries(this.patchesOwner),i.patches.has(t)||i.patches.set(t,[]),i.patches.get(t).push(this)}generatePatchEntries(t,e=void 0){let s=this?.options.condition;Reflect.ownKeys(t).forEach(r=>{let n=this?.options?.conditions?.[r]??s;try{let o=e??i.getDescriptorOverridesFromSymbol(r),a=t;if(i.isKnownPatchSymbol(r)){a=i.constructWithStore(t[r],this,r),t[r]=a,this.generatePatchEntries(a,o);return}this.patchEntries[r]=new h(r,t,n,e),this.patchCount+=1}catch(o){console.error(`Failed to process patch for ${String(r)}
`,o)}if(Reflect.has(this.owner,r))try{this.patchConflicts[r]=new h(r,this.owner)}catch(o){console.error(`Cannot capture conflicting patch key ${r}
`,o)}})}get entries(){return Reflect.ownKeys(this.patchEntries).map(t=>[t,this.patchEntries[t]])}get appliedEntries(){return Reflect.ownKeys(this.patchEntries).filter(t=>this.patchState.get(t)===!0).map(t=>[t,this.patchEntries[t]])}get unappliedEntries(){return Reflect.ownKeys(this.patchEntries).filter(t=>this.patchState.get(t)===!1).map(t=>[t,this.patchEntries[t]])}get patches(){return this.entries.reduce((t,[e,s])=>(t[e]=s.computed,t),Object.create(null))}get appliedPatches(){return this.entries.reduce((t,[e,s])=>(this.patchState.get(e)===!0&&(t[e]=s.computed),t),Object.create(null))}get unappliedPatches(){return this.entries.reduce((t,[e,s])=>(this.patchState.get(e)===!1&&(t[e]=s.computed),t),Object.create(null))}get patchKeys(){return this.entries.map(([t,e])=>t)}get prettyEntries(){let t=s=>s?.[Symbol.toStringTag]??s?.name??String(s),e=this.entries.map(([s,r])=>i.stringRef(t(s),s,r));return Object.defineProperty(e,"asEntries",{get(){return this.map(s=>s.entry)},enumerable:!1,configurable:!0}),e}get conflicts(){return Reflect.ownKeys(this.patchConflicts).map(t=>[t,this.patchConflicts[t]])}get applied(){return this.patchesApplied>0}get isPartiallyPatched(){return this.applied}get isFullyPatched(){return this.patchCount==this.patchesApplied}apply(t){let e=this.entries,s={patches:e.length,applied:0,errors:[],notApplied:e.length};this.patchState.clear(),e.forEach(([,r])=>{if(r.isAllowed){Object.defineProperty(this.owner,r.key,r.descriptor);let n=Object.getOwnPropertyDescriptor(this.owner,r.key);this.#e(n,r.descriptor)?(s.applied+=1,s.notApplied-=1,this.patchState.set(r,!0)):(s.errors.push([r,new Error(`Could not apply patch for key ${r.key}`)]),this.patchState.set(r,!1))}else this.patchState.set(r,!1)}),this.patchesApplied=s.applied,typeof t=="function"&&t(s)}createToggle(t=!1){return new b(this,t)}revert(t){if(!this.applied)return;let e=this.entries,s=this.conflicts,r={patches:e.length,reverted:0,restored:0,conflicts:s.length,errors:[],stillApplied:0};e.forEach(([,n])=>{delete this.owner[n.key]?(this.patchesApplied-=1,r.reverted+=1,this.patchState.set(n,!1)):r.errors.push([n,new Error(`Failed to revert patch ${n.key}`)])}),s.forEach(([,n])=>{Object.defineProperty(this.owner,n.key,n.descriptor);let o=Object.getOwnPropertyDescriptor(this.owner,n.key);this.#e(n.descriptor,o)?r.restored+=1:r.errors.push([n,new Error(`Failed to restore original ${n.key}`)])}),r.stillApplied=this.patchesApplied,typeof t=="function"&&t(r)}release(){let t=i.patches.get(this.owner);t.splice(t.find(e=>e===this),1)}owner=null;options=null;patchState=new Map;[Symbol.iterator](){return this.entries.values()}#e(t,e){return!t||!e?!1:t.configurable===e.configurable&&t.enumerable===e.enumerable&&t.value===e.value&&t.writable===e.writable&&t.get===e.get&&t.set===e.set}[Symbol.for("nodejs.util.inspect.custom")](t,e,s){let r={get quotes(){return/^(\x1B\[\d+m)?['"]|["'](\x1B\[\d+m)?$/g},get arrays(){return/^(\x1B\[\d+m)?\[ | \](\x1B\[\d+m)?$/g}},n={...e,depth:t},o=this.ownerDisplayName??"",a=o.length?`[${s(o,e).replaceAll(r.quotes,"$1$2")}]`:"",l=s(this.patchKeys,n).replaceAll(r.arrays,"$1$2").replaceAll(/'(.*?)'/g,"$1");return`${this.constructor.name}${a} { ${l} }`}static patches=new Map;static enableFor(t){if(i.patches.has(t))for(let e of i.patches.get(t))e.apply()}static enableProbableStatics(){for(let t of i.patches.keys())typeof t=="function"&&i.enableFor(t)}static enableProbableInstances(){for(let t of i.patches.keys())typeof t!="function"&&i.enableFor(t)}static enableAll(){for(let t of i.patches.keys())i.enableFor(t)}static disableFor(t){if(i.patches.has(t))for(let e of i.patches.get(t))e.revert()}static disableAll(){for(let t of i.patches.keys())i.disableFor(t)}static disableProbableStatics(){for(let t of i.patches.keys())typeof t=="function"&&i.disableFor(t)}static disableProbableInstances(){for(let t of i.patches.keys())typeof t!="function"&&i.disableFor(t)}static get applied(){return this.#t(globalThis,!0)}static get known(){return this.#t(globalThis,!1)}static get use(){return this.#t(globalThis,!1,!0)}static get lazy(){return this.#t(globalThis,!1,!1,!0)}static scopedTo(t){let e=(s,r,n=!1,o=!1)=>this.#t(s,r,n,o);return{get applied(){return e(t,!0,!1)},get known(){return e(t,!1,!1)},get use(){return e(t,!1,!0)},get lazy(){return e(t,!1,!1,!0)}}}static#t(t,e,s=!1,r=!1){return[...i.patches.values()].flat().filter(n=>n.owner===t).reduce((n,o)=>{for(let[,a]of o.entries)if(!(e&&o.patchState.get(a)!==!0)){if(s){n[a.key]=async l=>{if(typeof l!="function")return;let c=Object.prototype.toString.call(l),p=o.createToggle();p.start(),c==="[object AsyncFunction]"?await l(a.computed,a):l(a.computed,a),p.stop()};continue}if(r){Object.defineProperty(n,a.key,{get(){return o.apply(),a.computed},enumerable:!0,configurable:!0});continue}if(a.isAccessor){let l=`applyAccessorFor_${String(a.key)}`,c={[l](p){return a.applyTo(p),p}};n[a.key]=c[l]}else a.applyTo(n)}return n},Object.create(null))}static get CustomInspect(){return Symbol.for("nodejs.util.inspect.custom")}static stripExtras(t){return t.replaceAll(/^(\x1B\[\d+m)?[\[\{]\s?|\s?[\]\}](\x1B\[\d+m)?$/gm,"$1$2").replaceAll(/['"](.*?)['"]/gm,"$1")}static get kMutablyHidden(){return Symbol.for('{"enumerable":false,"configurable":true}')}static mutablyHidden(t,e=Object.create(null)){return this.customDescriptorPatch(t,this.kMutablyHidden,e)}static get kMutablyVisible(){return Symbol.for('{"enumerable":true,"configurable":true}')}static mutablyVisible(t,e=Object.create(null)){return this.customDescriptorPatch(t,this.kMutablyVisible,e)}static get kImmutablyHidden(){return Symbol.for('{"enumerable":false,"configurable":false}')}static immutablyHidden(t,e=Object.create(null)){return this.customDescriptorPatch(t,this.kImmutablyHidden,e)}static get kImmutablyVisible(){return Symbol.for('{"enumerable":true,"configurable":false}')}static immutablyVisible(t,e=Object.create(null)){return this.customDescriptorPatch(t,this.kImmutablyVisible,e)}static customDescriptorPatch(t,e,s=Object.create(null)){return!this.stores.has(t)&&(this.stores.set(t,s),i.isKnownPatchSymbol(e))?(s[e]=Object.create(null),this.stores.get(t)[e]):this.stores.get(t)}static isKnownPatchSymbol(t){return typeof t=="symbol"?[this.kImmutablyHidden,this.kImmutablyVisible,this.kMutablyHidden,this.kMutablyVisible].some(e=>e===t):!1}static constructWithStore(t,e,s,r=Object.create(null)){if(typeof t!="function")return t;try{let n=i.customDescriptorPatch(e,s,r);return t(n)}catch(n){return console.error(n),t}}static getDescriptorOverridesFromSymbol(t){let e=Object.create(null);return this.isKnownPatchSymbol(t)&&(e=JSON.parse(t.description)),e}static stores=new WeakMap;static stringRef(t,e,s){return Object.assign(Object(t),{get key(){return e},get value(){return s},get entry(){return[e,s]},get entries(){return[this.entry]},valueOf(){return String(this)},[Symbol.toStringTag]:"String",[Symbol.for("nodejs.util.inspect.custom")](n,o,a){return a(String(this),{colors:!0})}})}};var v=["number","boolean","bigint","string","symbol"],g=class i extends u{constructor(t,e,s=globalThis,r={}){let n=i.determineInput(t),{key:o,extension:a,valid:l}=n;if(a=e||a,!l)throw new d(s,o);let c=Object.getOwnPropertyDescriptor(s,o);if(c&&(Reflect.has(c,"writable")&&!c.writable||Reflect.has(c,"configurable")&&!c.configurable))throw new f(s,o);super(s,{[o]:a},r),this.key=o,this.class=n.class,this.function=n.function}get isFunction(){return!!this.function}get isClass(){return!!this.class}get isPrimitive(){return~v.indexOf(typeof this.value)}get isObject(){return Object(this.value)===this.value}static get applied(){return u.applied}static get known(){return u.known}static get use(){return u.use}static get lazy(){return u.lazy}static scopedTo(t){return u.scopedTo(t)}static determineInput(t){let e={key:null,extension:null,valid:!1};return t instanceof Function?(e={key:t.name,extension:t,valid:!0},/^class .*/.exec(t.toString())&&(e.class=t),/^(async )?function .*/.exec(t.toString())&&(e.function=t)):(typeof t=="string"||t instanceof String)&&(e={key:t,extension:null,valid:!0}),e}[Symbol.for("nodejs.util.inspect.custom")](t,e,s){let r={get braces(){return/^(\x1B\[\d+m)?[\[\{]|[\]\}](\x1B\[\d+m)?$/g},get quotes(){return/^(\x1B\[\d+m)?['"]|["'](\x1B\[\d+m)?$/g}},n=s(this.key,e).replaceAll(r.quotes,"$1$2"),o=s(this.patches[this.key],e).replaceAll(r.braces,"$1$2");return`Extension[${n}:${o}]`}get[Symbol.toStringTag](){return this.constructor.name}static createSet(t,...e){return new i.ExtensionSet(t,...e)}static ExtensionSet=class{constructor(e,...s){this.name=e,this.extensionObjects=new Set,this.extensions=new Set;for(let r of s)r instanceof i?(this.extensions.add(r),this.extensionObjects.add(r.patches[r.key])):r instanceof Function&&(this.extensionObjects.add(r),this.extensions.add(new i(r)))}apply(){for(let e of this.extensions)e.apply()}revert(){for(let e of this.extensions)e.revert()}}};var A={get CannotBeExtended(){return f},get MissingOwnerValue(){return d}};return $(T);})();
//# sourceMappingURL=extension.bundle.2.9.0.js.map
