{
  "version": 3,
  "sources": ["../../src/index.js", "../../src/errors/CannotBeExtendedError.js", "../../src/errors/MissingOwnerValue.js", "../../src/patch.js", "../../src/extension.js", "../../src/patchcleaner.js"],
  "sourcesContent": ["export { Extension } from './extension.js'\nexport { Patch } from './patch.js'\nexport { PatchCleaner } from './patchcleaner.js'\n\nimport { CannotBeExtendedError } from './errors/CannotBeExtendedError.js'\nimport { MissingOwnerValue } from './errors/MissingOwnerValue.js'\n\nexport const Errors = {\n  get CannotBeExtended() { return CannotBeExtendedError },\n  get MissingOwnerValue() { return MissingOwnerValue },\n}\n", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1]\n\n/**\n * Represents an error that is thrown when there is an attempt to extend a\n * restricted part of the code. This error is specifically used to signal\n * violations of extension constraints, such as tampering with certain keys\n * or properties of an object. The error message constructed will include the\n * details of the owner (the restricted part) and the key that was attempted to\n * be tampered with.\n */\nexport class CannotBeExtendedError extends Error {\n  /**\n   * Constructs a new CannotBeExtendedError instance.\n   *\n   * @param {string} owner The name or identifier of the restricted part\n   * that is disallowing extension or tampering.\n   * @param {string} key The key or property that was attempted to be\n   * modified or extended.\n   */\n  constructor(owner, key) {\n    super(`${typeOf(owner)} disallows tampering with ${key}.`)\n    Object.assign(this, { owner, key })\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Overrides the default\n   * Object.prototype.toString behavior, returning the constructor's name\n   * of this error instance. Useful for debugging and logging purposes.\n   * @returns {string} The name of the constructor for this error instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}\n", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1]\n\n/**\n * Represents an error that is thrown when a property is missing from a specified\n * owner object. This error is used to indicate that a specific key or property\n * expected to be present on the owner is not found, highlighting potential issues\n * in property access or data integrity.\n */\nexport class MissingOwnerValue extends Error {\n  /**\n   * Constructs a new MissingOwnerValue instance.\n   *\n   * @param {string} owner The object or entity that is supposed to contain the\n   * property.\n   * @param {string} key The name of the property that is missing from the owner.\n   */\n  constructor(owner, key) {\n    super(`${typeOf(owner)} does not have a property named '${key}'.`)\n    Object.assign(this, { owner, key })\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Overrides the default\n   * Object.prototype.toString behavior, returning the constructor's name\n   * of this error instance. Useful for debugging and logging purposes.\n   *\n   * @returns {string} The name of the constructor for this error instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}\n", "/**\n * The Patch class provides a mechanism to apply patches to properties or\n * methods of an object (the owner). It keeps track of the original state of\n * these properties and allows for the application and reversion of patches.\n */\nexport class Patch {\n  /**\n   * Constructs a new Patch instance.\n   *\n   * @param {object} owner The object to which patches will be applied.\n   * @param {object} patches An object containing properties or methods to\n   *                         be patched onto the owner.\n   * @param {object} [options={}] Additional options for patching behavior.\n   */\n  constructor(owner, patches, options = {}) {\n    Object.assign(this, {\n      owner,\n      options,\n      applied: false,\n    })\n\n    this.patchConflicts = {}\n    this.patchEntries = {}\n    this.patchesOwner = patches\n\n    Reflect.ownKeys(patches).forEach(key => {\n      this.patchEntries[key] = new Patch.#PatchEntry(key, this.patchesOwner)\n\n      if (Reflect.has(this.owner, key)) {\n        this.patchConflicts[key] = new Patch.#PatchEntry(key, this.owner)\n      }\n    })\n\n    if (!Patch.patches.has(owner)) {\n      Patch.patches.set(owner, [])\n    }\n\n    Patch.patches.get(owner).push(this)\n  }\n\n  /**\n   * Retrieves the patch entries as an array of [key, patchEntry] pairs.\n   *\n   * @returns {Array} An array of [key, patchEntry] pairs.\n   */\n  get patches() {\n    return Reflect.ownKeys(this.patchEntries).map(key => {\n      return [key, this.patchEntries[key]]\n    })\n  }\n\n  /**\n   * Retrieves the conflict entries (existing properties on the owner that\n   * will be overridden by patches) as an array of [key, patchEntry] pairs.\n   *\n   * @returns {Array} An array of [key, patchEntry] pairs.\n   */\n  get conflicts() {\n    return Reflect.ownKeys(this.patchConflicts).map(key => {\n      return [key, this.patchConflicts[key]]\n    })\n  }\n\n  /**\n   * Applies all patches to the owner object. If a property with the same key\n   * already exists on the owner, it will be overridden.\n   */\n  apply() {\n    if (!this.applied) {\n      this.patches.forEach(([,patch]) => {\n        Object.defineProperty(this.owner, patch.key, patch.descriptor)\n      })\n\n      this.applied = true\n    }\n  }\n\n  /**\n   * Reverts all applied patches on the owner object, restoring any overridden\n   * properties to their original state.\n   */\n  revert() {\n    if (this.applied) {\n      this.patches.forEach(([,patch]) => {\n        delete this.owner[patch.key]\n      })\n\n      this.conflicts.forEach(([,patch]) => {\n        Object.defineProperty(this.owner, patch.key, patch.descriptor)\n      })\n\n      this.applied = false\n    }\n  }\n\n  /**\n   * Removes this Patch instance from being tracked amongst all the tracked Patch\n   * instances. The JavaScript virtual machine will clean this instance up once\n   * nothing else is holding a reference to it.\n   */\n  release() {\n    const patches = Patch.patches.get(this.owner)\n    patches.splice(patches.find(e => e === this), 1)\n  }\n\n  /**\n   * The object to which the patches are applied.\n   */\n  owner = null\n\n  /**\n   * Additional options for patching behavior.\n   */\n  options = null\n\n  /**\n   * A global mapping of all patches in play\n   */\n  static patches = new Map()\n\n  /**\n   * Applies all patches associated with a given owner object. This method\n   * is used to enable all patches for a specific owner if they have been\n   * previously registered.\n   *\n   * @param {object} owner The object whose patches are to be applied.\n   */\n  static enableFor(owner) {\n    if (Patch.patches.has(owner)) {\n      for (const patch of Patch.patches.get(owner)) {\n        patch.apply()\n      }\n    }\n  }\n\n  /**\n   * Reverts all patches associated with a given owner object. This method\n   * is used to disable all patches for a specific owner if they have been\n   * previously applied.\n   *\n   * @param {object} owner The object whose patches are to be reverted.\n   */\n  static disableFor(owner) {\n    if (Patch.patches.has(owner)) {\n      for (const patch of Patch.patches.get(owner)) {\n        patch.revert()\n      }\n    }\n  }\n\n  /**\n   * Internal class representing a single patch entry.\n   */\n  static #PatchEntry = class {\n    /**\n     * Constructs a new PatchEntry instance.\n     *\n     * @param {string} property The property key to be patched.\n     * @param {object} [owningObject=globalThis] The object from which the\n     * property descriptor is taken.\n     */\n    constructor(property, owningObject = globalThis) {\n      Object.assign(this, {\n        key: property,\n        descriptor: Object.getOwnPropertyDescriptor(owningObject, property),\n        owner: owningObject\n      })\n    }\n\n    /**\n     * Computes and returns the current value of the patch, based on its type\n     * (data or accessor).\n     *\n     * @returns {any} The current value of the patch.\n     */\n    get computed() {\n      if (this.isAccessor) {\n        return this.descriptor.get.bind(this.owner).call()\n      }\n      else {\n        return this.descriptor.value\n      }\n    }\n\n    /**\n     * Checks if the patch is a data property (has a value).\n     *\n     * @returns {boolean} True if the patch is a data property, false otherwise.\n     */\n    get isData() {\n      return Reflect.has(this.descriptor, 'value')\n    }\n\n    /**\n     * Checks if the patch is an accessor property (has a getter).\n     *\n     * @returns {boolean} True if the patch is an accessor property, false otherwise.\n     */\n    get isAccessor() {\n      return Reflect.has(this.descriptor, 'get')\n    }\n\n    /**\n     * Checks if the patch is read-only (not configurable or not writable).\n     *\n     * @returns {boolean} True if the patch is read-only, false otherwise.\n     */\n    get isReadOnly() {\n      return (\n        (Reflect.has(this.descriptor, 'configurable') && !this.descriptor.configurable) ||\n        (Reflect.has(this.descriptor, 'writable') && !this.descriptor.writable)\n      )\n    }\n\n    /**\n     * Custom getter for the toStringTag symbol. Provides the class name of\n     * the PatchEntry instance.\n     *\n     * @returns {string} The class name of the PatchEntry instance.\n     */\n    get [Symbol.toStringTag]() {\n      return this.constructor.name\n    }\n\n    /**\n     * Custom inspect function for Node.js that provides a formatted representation\n     * of the PatchEntry instance, primarily for debugging purposes.\n     *\n     * @param {number} depth The depth to which the object should be formatted.\n     * @param {object} options Formatting options.\n     * @param {function} inspect The inspection function to format the object.\n     * @returns {string} A formatted string representing the PatchEntry instance.\n     */\n    [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n      return `PatchEntry<${\n        this.key\n      }, ${\n        this.isData ? 'Data' : 'Accessor'\n      }${this.isReadOnly ? ' [ReadOnly]' : ''}>`\n    }\n  }\n}", "import { CannotBeExtendedError } from \"./errors/CannotBeExtendedError.js\"\nimport { MissingOwnerValue } from './errors/MissingOwnerValue.js'\nimport { Patch } from './patch.js'\n\n/**\n * The Extension class, inheriting from the Patch class, is specifically designed\n * for extending properties or methods of a given object. It facilitates the\n * extension process by determining the target key and value for the extension and\n * ensuring the target property is writable and configurable. If these conditions\n * are not met, the class throws a CannotBeExtendedError. This class is useful\n * in scenarios like testing, dynamic behavior adjustments, or managing complex\n * object configurations.\n */\nexport class Extension extends Patch {\n  /**\n   * Constructs a new Extension instance. This constructor initializes the extension\n   * by determining the target key and value for the extension and ensuring that\n   * the property to be extended is configurable and writable. It throws an error\n   * if these conditions are not satisfied. The constructor leverages the Patch\n   * class's functionalities to manage the extension effectively.\n   *\n   * @param {Function|string} keyClassOrFn - The key, class, or function to be\n   * used for the extension. If a function or class is provided, its name is used\n   * as the key.\n   * @param {*} value - The value or method to be used for the extension.\n   * @param {object} [owner=globalThis] - The object to which the extension will\n   * be applied.\n   * @param {object} [options={}] - Additional options for the extension behavior.\n   * @throws {CannotBeExtendedError} If the target property is not writable or\n   * configurable.\n   * @throws {MissingOwnerValue} If the `keyClassOrFn` value is null or there\n   * is an error determining the key and extension values, MissingOwnerValue is\n   * thrown.\n   */\n  constructor(keyClassOrFn, value, owner = globalThis, options = {}) {\n    let { key, extension, valid } = Extension.determineInput(keyClassOrFn)\n    extension = value || extension\n\n    if (!valid) {\n      throw new MissingOwnerValue(owner, key)\n    }\n\n    const descriptor = Object.getOwnPropertyDescriptor(owner, key)\n    if (descriptor) {\n      if (\n        (Reflect.has(descriptor, 'writable') && !descriptor.writable) ||\n        (Reflect.has(descriptor, 'configurable') && !descriptor.configurable)\n      ) {\n        throw new CannotBeExtendedError(owner, key)\n      }\n    }\n\n    super(owner, { [key]: extension }, options)\n    this.key = key\n  }\n\n  /**\n   * Determines the input type for the extension. This method processes the input\n   * and identifies the key for the extension and the associated value or method.\n   * It supports inputs as either a string key or a function/class, providing\n   * flexibility in defining extensions.\n   *\n   * @param {Function|string} keyClassOrFn - The key, class, or function provided\n   * as input. If a function or class is provided, its name is used as the key.\n   * containing the determined key, the extension value/method, and a validity flag\n   * indicating whether the input is usable.\n   * @returns {{key: string|null, extension: *|null, valid: boolean}} An object\n   */\n  static determineInput(keyClassOrFn) {\n    let input = { key: null, extension: null, valid: false }\n\n    if (keyClassOrFn instanceof Function) {\n      input = { key: keyClassOrFn.name, extension: keyClassOrFn, valid: true }\n    }\n    else if (typeof keyClassOrFn === 'string' || keyClassOrFn instanceof String) {\n      input = { key: keyClassOrFn, extension: null, valid: true }\n    }\n\n    return input\n  }\n\n  /**\n   * Custom inspect function for Node.js that provides a formatted representation\n   * of the Extension instance, primarily for debugging purposes.\n   *\n   * @param {number} depth The depth to which the object should be formatted.\n   * @param {object} options Formatting options.\n   * @param {function} inspect The inspection function to format the object.\n   * @returns {string} A formatted string representing the Extension instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    return `Extension<${this.key}>`\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Provides the class name when the\n   * object is converted to a string, typically used for debugging and logging.\n   *\n   * @returns {string} The class name of the Extension instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}", "/**\n * The PatchCleaner class provides functionality for conditional cleanup of patches.\n * It allows for the reversion of patches based on specific criteria, ensuring that\n * patches are only reverted when necessary.\n */\nexport class PatchCleaner {\n  /**\n   * Constructs a new PatchCleaner instance. The instance itself is a function\n   * designed for cleanup. When called, it checks if the associated patch needs\n   * cleanup and reverts it if necessary.\n   *\n   * @param {Patch} patch The patch instance to be potentially cleaned up.\n   * @returns {Function} A cleanup function bound to the current context.\n   */\n  constructor(patch) {\n    function extensionCleanup() {\n      console.log(this)\n      if (PatchCleaner.needsCleanup(patch)) {\n        patch.revert()\n      }\n    }\n\n    Object.assign(extensionCleanup, this);\n    Object.setPrototypeOf(extensionCleanup, Object.getPrototypeOf(this));\n\n    return extensionCleanup\n  }\n\n  /**\n   * Determines whether a given patch needs cleanup. A patch needs cleanup if\n   * all of its patch entries still exist on the owner object.\n   *\n   * @param {Patch} patch The patch to check for cleanup necessity.\n   * @returns {boolean} True if the patch needs cleanup, false otherwise.\n   */\n  static needsCleanup(patch) {\n    const needsIt = Object.keys(patch.patchEntries).every(\n      key => Reflect.has(patch.owner, key)\n    )\n\n    return needsIt\n  }\n}"],
  "mappings": "obAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,YAAAE,EAAA,cAAAC,EAAA,UAAAC,EAAA,iBAAAC,ICCA,IAAMC,EAASC,GAAK,SAAS,KAAK,OAAO,UAAU,SAAS,KAAKA,CAAC,CAAC,EAAE,CAAC,EAUzDC,EAAN,cAAoC,KAAM,CAS/C,YAAYC,EAAOC,EAAK,CACtB,MAAM,GAAGJ,EAAOG,CAAK,CAAC,6BAA6BC,CAAG,GAAG,EACzD,OAAO,OAAO,KAAM,CAAE,MAAAD,EAAO,IAAAC,CAAI,CAAC,CACpC,CAQA,IAAK,OAAO,WAAW,GAAI,CACzB,OAAO,KAAK,YAAY,IAC1B,CACF,ECjCA,IAAMC,EAASC,GAAK,SAAS,KAAK,OAAO,UAAU,SAAS,KAAKA,CAAC,CAAC,EAAE,CAAC,EAQzDC,EAAN,cAAgC,KAAM,CAQ3C,YAAYC,EAAOC,EAAK,CACtB,MAAM,GAAGJ,EAAOG,CAAK,CAAC,oCAAoCC,CAAG,IAAI,EACjE,OAAO,OAAO,KAAM,CAAE,MAAAD,EAAO,IAAAC,CAAI,CAAC,CACpC,CASA,IAAK,OAAO,WAAW,GAAI,CACzB,OAAO,KAAK,YAAY,IAC1B,CACF,EC3BO,IAAMC,EAAN,MAAMC,CAAM,CASjB,YAAYC,EAAOC,EAASC,EAAU,CAAC,EAAG,CACxC,OAAO,OAAO,KAAM,CAClB,MAAAF,EACA,QAAAE,EACA,QAAS,EACX,CAAC,EAED,KAAK,eAAiB,CAAC,EACvB,KAAK,aAAe,CAAC,EACrB,KAAK,aAAeD,EAEpB,QAAQ,QAAQA,CAAO,EAAE,QAAQE,GAAO,CACtC,KAAK,aAAaA,CAAG,EAAI,IAAIJ,EAAMK,GAAYD,EAAK,KAAK,YAAY,EAEjE,QAAQ,IAAI,KAAK,MAAOA,CAAG,IAC7B,KAAK,eAAeA,CAAG,EAAI,IAAIJ,EAAMK,GAAYD,EAAK,KAAK,KAAK,EAEpE,CAAC,EAEIJ,EAAM,QAAQ,IAAIC,CAAK,GAC1BD,EAAM,QAAQ,IAAIC,EAAO,CAAC,CAAC,EAG7BD,EAAM,QAAQ,IAAIC,CAAK,EAAE,KAAK,IAAI,CACpC,CAOA,IAAI,SAAU,CACZ,OAAO,QAAQ,QAAQ,KAAK,YAAY,EAAE,IAAIG,GACrC,CAACA,EAAK,KAAK,aAAaA,CAAG,CAAC,CACpC,CACH,CAQA,IAAI,WAAY,CACd,OAAO,QAAQ,QAAQ,KAAK,cAAc,EAAE,IAAIA,GACvC,CAACA,EAAK,KAAK,eAAeA,CAAG,CAAC,CACtC,CACH,CAMA,OAAQ,CACD,KAAK,UACR,KAAK,QAAQ,QAAQ,CAAC,CAAC,CAACE,CAAK,IAAM,CACjC,OAAO,eAAe,KAAK,MAAOA,EAAM,IAAKA,EAAM,UAAU,CAC/D,CAAC,EAED,KAAK,QAAU,GAEnB,CAMA,QAAS,CACH,KAAK,UACP,KAAK,QAAQ,QAAQ,CAAC,CAAC,CAACA,CAAK,IAAM,CACjC,OAAO,KAAK,MAAMA,EAAM,GAAG,CAC7B,CAAC,EAED,KAAK,UAAU,QAAQ,CAAC,CAAC,CAACA,CAAK,IAAM,CACnC,OAAO,eAAe,KAAK,MAAOA,EAAM,IAAKA,EAAM,UAAU,CAC/D,CAAC,EAED,KAAK,QAAU,GAEnB,CAOA,SAAU,CACR,IAAMJ,EAAUF,EAAM,QAAQ,IAAI,KAAK,KAAK,EAC5CE,EAAQ,OAAOA,EAAQ,KAAK,GAAK,IAAM,IAAI,EAAG,CAAC,CACjD,CAKA,MAAQ,KAKR,QAAU,KAKV,OAAO,QAAU,IAAI,IASrB,OAAO,UAAUD,EAAO,CACtB,GAAID,EAAM,QAAQ,IAAIC,CAAK,EACzB,QAAWK,KAASN,EAAM,QAAQ,IAAIC,CAAK,EACzCK,EAAM,MAAM,CAGlB,CASA,OAAO,WAAWL,EAAO,CACvB,GAAID,EAAM,QAAQ,IAAIC,CAAK,EACzB,QAAWK,KAASN,EAAM,QAAQ,IAAIC,CAAK,EACzCK,EAAM,OAAO,CAGnB,CAKA,MAAOD,GAAc,KAAM,CAQzB,YAAYE,EAAUC,EAAe,WAAY,CAC/C,OAAO,OAAO,KAAM,CAClB,IAAKD,EACL,WAAY,OAAO,yBAAyBC,EAAcD,CAAQ,EAClE,MAAOC,CACT,CAAC,CACH,CAQA,IAAI,UAAW,CACb,OAAI,KAAK,WACA,KAAK,WAAW,IAAI,KAAK,KAAK,KAAK,EAAE,KAAK,EAG1C,KAAK,WAAW,KAE3B,CAOA,IAAI,QAAS,CACX,OAAO,QAAQ,IAAI,KAAK,WAAY,OAAO,CAC7C,CAOA,IAAI,YAAa,CACf,OAAO,QAAQ,IAAI,KAAK,WAAY,KAAK,CAC3C,CAOA,IAAI,YAAa,CACf,OACG,QAAQ,IAAI,KAAK,WAAY,cAAc,GAAK,CAAC,KAAK,WAAW,cACjE,QAAQ,IAAI,KAAK,WAAY,UAAU,GAAK,CAAC,KAAK,WAAW,QAElE,CAQA,IAAK,OAAO,WAAW,GAAI,CACzB,OAAO,KAAK,YAAY,IAC1B,CAWA,CAAC,OAAO,IAAI,4BAA4B,CAAC,EAAEC,EAAON,EAASO,EAAS,CAClE,MAAO,cACL,KAAK,GACP,KACE,KAAK,OAAS,OAAS,UACzB,GAAG,KAAK,WAAa,cAAgB,EAAE,GACzC,CACF,CACF,ECpOO,IAAMC,EAAN,MAAMC,UAAkBC,CAAM,CAqBnC,YAAYC,EAAcC,EAAOC,EAAQ,WAAYC,EAAU,CAAC,EAAG,CACjE,GAAI,CAAE,IAAAC,EAAK,UAAAC,EAAW,MAAAC,CAAM,EAAIR,EAAU,eAAeE,CAAY,EAGrE,GAFAK,EAAYJ,GAASI,EAEjB,CAACC,EACH,MAAM,IAAIC,EAAkBL,EAAOE,CAAG,EAGxC,IAAMI,EAAa,OAAO,yBAAyBN,EAAOE,CAAG,EAC7D,GAAII,IAEC,QAAQ,IAAIA,EAAY,UAAU,GAAK,CAACA,EAAW,UACnD,QAAQ,IAAIA,EAAY,cAAc,GAAK,CAACA,EAAW,cAExD,MAAM,IAAIC,EAAsBP,EAAOE,CAAG,EAI9C,MAAMF,EAAO,CAAE,CAACE,CAAG,EAAGC,CAAU,EAAGF,CAAO,EAC1C,KAAK,IAAMC,CACb,CAcA,OAAO,eAAeJ,EAAc,CAClC,IAAIU,EAAQ,CAAE,IAAK,KAAM,UAAW,KAAM,MAAO,EAAM,EAEvD,OAAIV,aAAwB,SAC1BU,EAAQ,CAAE,IAAKV,EAAa,KAAM,UAAWA,EAAc,MAAO,EAAK,GAEhE,OAAOA,GAAiB,UAAYA,aAAwB,UACnEU,EAAQ,CAAE,IAAKV,EAAc,UAAW,KAAM,MAAO,EAAK,GAGrDU,CACT,CAWA,CAAC,OAAO,IAAI,4BAA4B,CAAC,EAAEC,EAAOR,EAASS,EAAS,CAClE,MAAO,aAAa,KAAK,GAAG,GAC9B,CAQA,IAAK,OAAO,WAAW,GAAI,CACzB,OAAO,KAAK,YAAY,IAC1B,CACF,EClGO,IAAMC,EAAN,MAAMC,CAAa,CASxB,YAAYC,EAAO,CACjB,SAASC,GAAmB,CAC1B,QAAQ,IAAI,IAAI,EACZF,EAAa,aAAaC,CAAK,GACjCA,EAAM,OAAO,CAEjB,CAEA,cAAO,OAAOC,EAAkB,IAAI,EACpC,OAAO,eAAeA,EAAkB,OAAO,eAAe,IAAI,CAAC,EAE5DA,CACT,CASA,OAAO,aAAaD,EAAO,CAKzB,OAJgB,OAAO,KAAKA,EAAM,YAAY,EAAE,MAC9CE,GAAO,QAAQ,IAAIF,EAAM,MAAOE,CAAG,CACrC,CAGF,CACF,ELnCO,IAAMC,EAAS,CACpB,IAAI,kBAAmB,CAAE,OAAOC,CAAsB,EACtD,IAAI,mBAAoB,CAAE,OAAOC,CAAkB,CACrD",
  "names": ["src_exports", "__export", "Errors", "Extension", "Patch", "PatchCleaner", "typeOf", "o", "CannotBeExtendedError", "owner", "key", "typeOf", "o", "MissingOwnerValue", "owner", "key", "Patch", "_Patch", "owner", "patches", "options", "key", "#PatchEntry", "patch", "property", "owningObject", "depth", "inspect", "Extension", "_Extension", "Patch", "keyClassOrFn", "value", "owner", "options", "key", "extension", "valid", "MissingOwnerValue", "descriptor", "CannotBeExtendedError", "input", "depth", "inspect", "PatchCleaner", "_PatchCleaner", "patch", "extensionCleanup", "key", "Errors", "CannotBeExtendedError", "MissingOwnerValue"]
}
