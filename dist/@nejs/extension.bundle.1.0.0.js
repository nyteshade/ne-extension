var nejsExtension=(()=>{var u=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var b=Object.prototype.hasOwnProperty;var y=(s,t)=>{for(var e in t)u(s,e,{get:t[e],enumerable:!0})},w=(s,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of m(t))!b.call(s,i)&&i!==e&&u(s,i,{get:()=>t[i],enumerable:!(r=g(t,i))||r.enumerable});return s};var x=s=>w(u({},"__esModule",{value:!0}),s);var R={};y(R,{Errors:()=>j,Extension:()=>h,Patch:()=>c,PatchCleaner:()=>l});var O=s=>/(\w+)]/.exec(Object.prototype.toString.call(s))[1],o=class extends Error{constructor(t,e){super(`${O(t)} disallows tampering with ${e}.`),Object.assign(this,{owner:t,key:e})}get[Symbol.toStringTag](){return this.constructor.name}};var E=s=>/(\w+)]/.exec(Object.prototype.toString.call(s))[1],n=class extends Error{constructor(t,e){super(`${E(t)} does not have a property named '${e}'.`),Object.assign(this,{owner:t,key:e})}get[Symbol.toStringTag](){return this.constructor.name}};var c=class s{constructor(t,e,r={}){Object.assign(this,{owner:t,options:r,applied:!1}),this.patchConflicts={},this.patchEntries={},this.patchesOwner=e,Reflect.ownKeys(e).forEach(i=>{this.patchEntries[i]=new s.#t(i,this.patchesOwner),Reflect.has(this.owner,i)&&(this.patchConflicts[i]=new s.#t(i,this.owner))}),s.patches.has(t)||s.patches.set(t,[]),s.patches.get(t).push(this)}get patches(){return Reflect.ownKeys(this.patchEntries).map(t=>[t,this.patchEntries[t]])}get conflicts(){return Reflect.ownKeys(this.patchConflicts).map(t=>[t,this.patchConflicts[t]])}apply(){this.applied||(this.patches.forEach(([,t])=>{Object.defineProperty(this.owner,t.key,t.descriptor)}),this.applied=!0)}revert(){this.applied&&(this.patches.forEach(([,t])=>{delete this.owner[t.key]}),this.conflicts.forEach(([,t])=>{Object.defineProperty(this.owner,t.key,t.descriptor)}),this.applied=!1)}release(){let t=s.patches.get(this.owner);t.splice(t.find(e=>e===this),1)}owner=null;options=null;static patches=new Map;static enableFor(t){if(s.patches.has(t))for(let e of s.patches.get(t))e.apply()}static disableFor(t){if(s.patches.has(t))for(let e of s.patches.get(t))e.revert()}static#t=class{constructor(t,e=globalThis){Object.assign(this,{key:t,descriptor:Object.getOwnPropertyDescriptor(e,t),owner:e})}get computed(){return this.isAccessor?this.descriptor.get.bind(this.owner).call():this.descriptor.value}get isData(){return Reflect.has(this.descriptor,"value")}get isAccessor(){return Reflect.has(this.descriptor,"get")}get isReadOnly(){return Reflect.has(this.descriptor,"configurable")&&!this.descriptor.configurable||Reflect.has(this.descriptor,"writable")&&!this.descriptor.writable}get[Symbol.toStringTag](){return this.constructor.name}[Symbol.for("nodejs.util.inspect.custom")](t,e,r){return`PatchEntry<${this.key}, ${this.isData?"Data":"Accessor"}${this.isReadOnly?" [ReadOnly]":""}>`}}};var h=class s extends c{constructor(t,e,r=globalThis,i={}){let{key:a,extension:f,valid:d}=s.determineInput(t);if(f=e||f,!d)throw new n(r,a);let p=Object.getOwnPropertyDescriptor(r,a);if(p&&(Reflect.has(p,"writable")&&!p.writable||Reflect.has(p,"configurable")&&!p.configurable))throw new o(r,a);super(r,{[a]:f},i),this.key=a}static determineInput(t){let e={key:null,extension:null,valid:!1};return t instanceof Function?e={key:t.name,extension:t,valid:!0}:(typeof t=="string"||t instanceof String)&&(e={key:t,extension:null,valid:!0}),e}[Symbol.for("nodejs.util.inspect.custom")](t,e,r){return`Extension<${this.key}>`}get[Symbol.toStringTag](){return this.constructor.name}};var l=class s{constructor(t){function e(){console.log(this),s.needsCleanup(t)&&t.revert()}return Object.assign(e,this),Object.setPrototypeOf(e,Object.getPrototypeOf(this)),e}static needsCleanup(t){return Object.keys(t.patchEntries).every(r=>Reflect.has(t.owner,r))}};var j={get CannotBeExtended(){return o},get MissingOwnerValue(){return n}};return x(R);})();
//# sourceMappingURL=extension.bundle.1.0.0.js.map
