{
  "version": 3,
  "sources": ["../../src/index.js", "../../src/errors/CannotBeExtendedError.js", "../../src/errors/MissingOwnerValue.js", "../../src/patchtoggle.js", "../../src/patchentry.js", "../../src/patch.js", "../../src/extension.js"],
  "sourcesContent": ["export { Extension } from './extension.js'\nexport { Patch } from './patch.js'\nexport { PatchEntry } from './patchentry.js'\nexport { PatchToggle } from './patchtoggle.js'\n\nimport { CannotBeExtendedError } from './errors/CannotBeExtendedError.js'\nimport { MissingOwnerValue } from './errors/MissingOwnerValue.js'\n\nexport const Errors = {\n  get CannotBeExtended() { return CannotBeExtendedError },\n  get MissingOwnerValue() { return MissingOwnerValue },\n}\n", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1]\n\n/**\n * Represents an error that is thrown when there is an attempt to extend a\n * restricted part of the code. This error is specifically used to signal\n * violations of extension constraints, such as tampering with certain keys\n * or properties of an object. The error message constructed will include the\n * details of the owner (the restricted part) and the key that was attempted to\n * be tampered with.\n */\nexport class CannotBeExtendedError extends Error {\n  /**\n   * Constructs a new CannotBeExtendedError instance.\n   *\n   * @param {string} owner The name or identifier of the restricted part\n   * that is disallowing extension or tampering.\n   * @param {string} key The key or property that was attempted to be\n   * modified or extended.\n   */\n  constructor(owner, key) {\n    super(`${typeOf(owner)} disallows tampering with ${key}.`)\n    Object.assign(this, { owner, key })\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Overrides the default\n   * Object.prototype.toString behavior, returning the constructor's name\n   * of this error instance. Useful for debugging and logging purposes.\n   * @returns {string} The name of the constructor for this error instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}\n", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1]\n\n/**\n * Represents an error that is thrown when a property is missing from a specified\n * owner object. This error is used to indicate that a specific key or property\n * expected to be present on the owner is not found, highlighting potential issues\n * in property access or data integrity.\n */\nexport class MissingOwnerValue extends Error {\n  /**\n   * Constructs a new MissingOwnerValue instance.\n   *\n   * @param {string} owner The object or entity that is supposed to contain the\n   * property.\n   * @param {string} key The name of the property that is missing from the owner.\n   */\n  constructor(owner, key) {\n    super(`${typeOf(owner)} does not have a property named '${key}'.`)\n    Object.assign(this, { owner, key })\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Overrides the default\n   * Object.prototype.toString behavior, returning the constructor's name\n   * of this error instance. Useful for debugging and logging purposes.\n   *\n   * @returns {string} The name of the constructor for this error instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}\n", "import { Patch } from \"./patch\";\n\n/**\n * Early usage of the Patch and Extension classes made it clear that it was\n * cumbersome to use a Patch temporarily for a block of code and excessive\n * amounts of if/else statements were required. This simple wrapper makes that\n * process easier.\n */\nexport class PatchToggle {\n  /**\n   * Wraps an instance of a Patch. It allows low-code clean-readability to\n   * start and stop the underlying patch regardless of whether or not the\n   * patch has been already applied.\n   *\n   * @param {Patch} patch instance of `Patch` to wrap with this toggle\n   * @param {boolean} preventRevert prevents the call to `.revert()` on the\n   * supplied patch when stop() is called.\n   */\n  constructor(patch, preventRevert = false) {\n    this.started = false\n    this.preventRevert = preventRevert\n    this.patch = patch\n    this.patchName = (\n      patch.owner?.name ??\n      patch.owner?.constructor?.name ??\n      /(\\w+)]/.exec(Object.prototype.toString.call(patch.owner))[1]\n    )\n    this.state = {\n      needsApplication: false,\n      needsReversion: false,\n    }\n  }\n\n  /**\n   * If the usage of the wrapped Patch hasn't been started yet, the code checks\n   * whether or not the patch has been applied by checking for signs of it in\n   * the owning object.\n   *\n   * If the patch needs to be applied, it will be applied at this time.\n   *\n   * @returns {PatchToggle} returns `this` to allow for chaining\n   */\n  start() {\n    if (!this.started) {\n      this.state.needsApplication = !this.patch.applied\n      this.state.needsReversion = this.patch.applied\n      this.started = true\n\n      if (this.state.needsApplication) {\n        this.patch.apply()\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Checks to see if the toggle has been started. If so, the patch is reverted\n   * if it needed to be applied previously. After stopping, the state of the instance\n   * is reverted to allow for clean subsequent calls to start.\n   *\n   * @returns {PatchToggle} returns `this` to allow further chaining\n   */\n  stop() {\n    if (this.started) {\n      if (this.preventRevert || this.patch.applied) {\n        this.patch.revert()\n      }\n\n      this.state.needsApplication = false\n      this.state.needsReversion = false\n      this.started = false\n    }\n\n    return this\n  }\n\n  /**\n   * When the string tag for this class instance is inspected, it will\n   * reflect the string `PatchToggle:PatchName`\n   */\n  get [Symbol.toStringTag]() {\n    return `${this.constructor.name}:${this.patchName}`\n  }\n\n  /**\n   * Custom inspect function for Node.js that provides a formatted representation\n   * of the PatchToggle instance, primarily for debugging purposes.\n   *\n   * @param {number} depth The depth to which the object should be formatted.\n   * @param {object} options Formatting options.\n   * @param {function} inspect The inspection function to format the object.\n   * @returns {string} A formatted string representing the PatchEntry instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const objName = this[Symbol.toStringTag]\n    const status = `(started: ${this.started} needed: ${this.state.needsApplication})`\n\n    return inspect(`${objName} ${status}`, {...options, depth})\n  }\n}", "/**\n * A PatchEntry class is a wrapper that maps the descriptor, key and owning\n * object in a single instance. When a Patch or Extension are created, one\n * of these for each patch is created so that the patch can be applied and\n * reverted.\n */\nexport class PatchEntry {\n  /**\n   * Constructs a new PatchEntry instance.\n   *\n   * @param {string|symbol} property The property key to be patched.\n   * @param {object} [owningObject=globalThis] The object from which the\n   * property descriptor is taken.\n   * @param {function} condition if a valid function is passed here, the\n   * expectation is that it takes no parameters and returns a `boolean`. If\n   * `true`, then this entry can be applied. If `false`, it indicates to the\n   * consuming `Patch` that it cannot be applied.\n   * @throws {TypeError} if `owningObject` is not a valid object (i.e. one that\n   * can contain property descriptors and assigned values), then a `TypeError`\n   * is thrown. A `TypeError` is also thrown if `property` is null, or neither\n   * an object nor symbol.\n   */\n  constructor(property, owningObject = globalThis, condition = undefined) {\n    const isNullish = (value) => (value === null || value === undefined)\n    const isKey = (value, types = ['string', 'symbol']) =>\n      !isNullish(value) && (!!types.find(f => f === (typeof value)))\n    const isObject = value => isKey(value, ['object'])\n\n    if (!isKey(property)) {\n      console.error(\n        'Property', property, `(type: ${typeof property})`,\n        'owningObject', owningObject, `(type: ${typeof owningObject})`,\n        'condition', condition, `(type: ${typeof condition})`,\n      )\n      throw new TypeError('Property must be non-null and either a string or symbol')\n    }\n\n    if (!isObject(owningObject)) {\n      throw new TypeError('Cannot create Patch entry as owning object is invalid')\n    }\n\n    Object.assign(this, {\n      key: property,\n      descriptor: Object.getOwnPropertyDescriptor(owningObject, property),\n      owner: owningObject,\n      condition: (typeof condition === 'function') ? condition : undefined\n    })\n  }\n\n  /**\n   * Computes and returns the current value of the patch, based on its type\n   * (data or accessor).\n   *\n   * @returns {any} The current value of the patch.\n   */\n  get computed() {\n    if (this.isAccessor) {\n      return this.descriptor.get.bind(this.owner).call()\n    }\n    else {\n      return this.descriptor.value\n    }\n  }\n\n  /**\n   * Checks if the patch is a data property (has a value).\n   *\n   * @returns {boolean} True if the patch is a data property, false otherwise.\n   */\n  get isData() {\n    return Reflect.has(this.descriptor, 'value')\n  }\n\n  /**\n   * Checks if the patch is an accessor property (has a getter).\n   *\n   * @returns {boolean} True if the patch is an accessor property, false otherwise.\n   */\n  get isAccessor() {\n    return Reflect.has(this.descriptor, 'get')\n  }\n\n  /**\n   * Checks if the patch is read-only (not configurable or not writable).\n   *\n   * @returns {boolean} True if the patch is read-only, false otherwise.\n   */\n  get isReadOnly() {\n    return (\n      (Reflect.has(this.descriptor, 'configurable') && !this.descriptor.configurable) ||\n      (Reflect.has(this.descriptor, 'writable') && !this.descriptor.writable)\n    )\n  }\n\n  /**\n   * If a `condition` is associated with this specific patch entry, then it will\n   * run and its result will be returned. Otherwise `true` is returned allowing\n   * all non-conditional `PatchEntry` instances to be applied every time.\n   *\n   * @returns {boolean} `true` if the condition is true or there is no condition\n   * applied to this instance. `false` if the condition fails.\n   */\n  get isAllowed() {\n    const validAndPresent = (\n      this.condition &&\n      typeof this.condition === 'function'\n    )\n\n    return validAndPresent ? this.condition() : true\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Provides the class name of\n   * the PatchEntry instance.\n   *\n   * @returns {string} The class name of the PatchEntry instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Custom inspect function for Node.js that provides a formatted representation\n   * of the PatchEntry instance, primarily for debugging purposes.\n   *\n   * @param {number} depth The depth to which the object should be formatted.\n   * @param {object} options Formatting options.\n   * @param {function} inspect The inspection function to format the object.\n   * @returns {string} A formatted string representing the PatchEntry instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const type = this.isData ? ' Data' : ' Accessor'\n    const writable = this.isReadOnly ? ' [ReadOnly]' : ''\n\n    return `PatchEntry<${this.key}${type}${writable}>`\n  }\n}\n", "import { PatchToggle } from './patchtoggle.js'\nimport { PatchEntry } from './patchentry.js'\n\n/**\n * The Patch class provides a mechanism to apply patches to properties or\n * methods of an object (the owner). It keeps track of the original state of\n * these properties and allows for the application and reversion of patches.\n */\nexport class Patch {\n  /**\n   * Constructs a new Patch instance. Supported options for Patch instances\n   * include either a global condition for the Patch to be applied or\n   * specific property conditions subjecting only a subset of the patches\n   * to conditional application.\n   *\n   * @example\n   * ```\n   * const custom = Symbol.for('nodejs.util.inspect.custom')\n   * const patch = new Patch(\n   *   Object,\n   *   {\n   *     property: 'value',\n   *     [custom](depth, options, inspect) {\n   *       // ... custom return string for nodejs\n   *     }\n   *   },\n   *   {\n   *     conditions: {\n   *       [custom]() { return process?.versions?.node !== null },\n   *     },\n   *   }\n   * )\n   * patch.apply() // applies `property` but only applies the `custom`\n   *               // property if the JavaScript is running in NodeJS\n   * ```\n   *\n   * @param {object} owner The object to which patches will be applied.\n   * @param {object} patches An object containing properties or methods to\n   *                         be patched onto the owner.\n   * @param {object} [options={}] Additional options for patching behavior.\n   */\n  constructor(owner, patches, options = {}) {\n    Object.assign(this, {\n      owner,\n      options,\n    })\n\n    this.patchConflicts = {}\n    this.patchEntries = {}\n    this.patchesOwner = patches\n    this.patchCount = 0\n    this.patchesApplied = 0\n\n    const globalCondition = this?.options.condition\n\n    Reflect.ownKeys(patches).forEach(key => {\n      const condition = this?.options?.conditions?.[key] ?? globalCondition\n      try {\n        this.patchEntries[key] = new PatchEntry(key, this.patchesOwner, condition)\n        this.patchCount += 1\n      }\n      catch (error) {\n        console.error(`Failed to process patch for ${key}\\n`, error)\n      }\n\n      if (Reflect.has(this.owner, key)) {\n        try {\n          this.patchConflicts[key] = new PatchEntry(key, this.owner)\n        }\n        catch (error) {\n          console.error(`Cannot capture conflicting patch key ${key}\\n`, error)\n        }\n      }\n    })\n\n    if (!Patch.patches.has(owner)) {\n      Patch.patches.set(owner, [])\n    }\n\n    Patch.patches.get(owner).push(this)\n  }\n\n  /**\n   * Retrieves the patch entries as an array of [key, patchEntry] pairs.\n   *\n   * @returns {Array} An array of [key, patchEntry] pairs.\n   */\n  get entries() {\n    return Reflect.ownKeys(this.patchEntries).map(key => {\n      return [key, this.patchEntries[key]]\n    })\n  }\n\n  /**\n   * Depending on how the PatchEntry is configured, accessing the patch\n   * by name can be somewhat irritating, so this provides an object with\n   * the actual current patch value at the time patchValues is requested.\n   *\n   * @example let { patch1, patch2 } = patch.patchValues\n   * @returns {object} an object with the patchName mapped to the current\n   * computed patchEntry value.\n   */\n  get patches() {\n    return this.entries.reduce((acc, [key, patchEntry]) => {\n      acc[key] = patchEntry.computed\n      return acc\n    }, {})\n  }\n\n  /**\n   * Retrieves the conflict entries (existing properties on the owner that\n   * will be overridden by patches) as an array of [key, patchEntry] pairs.\n   *\n   * @returns {Array} An array of [key, patchEntry] pairs.\n   */\n  get conflicts() {\n    return Reflect.ownKeys(this.patchConflicts).map(key => {\n      return [key, this.patchConflicts[key]]\n    })\n  }\n\n  /**\n   * Checks to see if the tracked number of applied patches is greater than 0\n   *\n   * @returns {boolean} true if at least one patch has been applied\n   */\n  get applied() {\n    return this.patchesApplied > 0\n  }\n\n  /**\n   * Provided for semantics, but this method is synonymous with {@link applied}.\n   *\n   * @returns {boolean} true if at least one patch has been applied\n   */\n  get isPartiallyPatched() {\n    return this.applied\n  }\n\n  /**\n   * Returns true only when the number of tracked patches matches the number\n   * of applied patches.\n   *\n   * @returns {boolean} true if applied patches is equal to the count of patches\n   */\n  get isFullyPatched() {\n    return this.patchCount == this.patchesApplied\n  }\n\n  /**\n   * Applies all patches to the owner object. If a property with the same key\n   * already exists on the owner, it will be overridden. Optionally a callback\n   * can be supplied to the call to revert. If the callback is a valid function,\n   * it will be invoked with an object containing the results of the reversion\n   * of the patch. The callback receives a single parameter which is an object\n   * of counts. It has the signature:\n   *\n   * ```\n   * type counts = {\n   *   patches: number;\n   *   applied: number;\n   *   errors: Array<PatchEntry,Error>;\n   *   notApplied: number;\n   * }\n   * ```\n   *\n   * While the keys may be obvious to some, `patches` is the count of patches\n   * this instance tracks. `applied` is the number of patches that were applied\n   * 'errors' is an array of arrays where the first element is the `PatchEntry`\n   * and the second element is an `Error` indicating the problem. An error will\n   * only be generated if `isAllowed` is `true` and the patch still failed to\n   * apply Lastly `notApplied` is the number of patches that were unable to\n   * be applied.\n   *\n   * Additional logic that should track\n   * ```\n   *   \u2022 patches should === applied when done\n   *   \u2022 errors.length should be 0 when done\n   *   \u2022 notApplied should be 0 when done\n   * ```\n   *\n   * @param {function} metrics - a callback which receives a status of the\n   * `revert` action if supplied. This callback will not be invoked, nor will\n   * any of the other logic be captured, if {@link applied} returns false\n   */\n  apply(metrics) {\n    const entries = this.entries\n    const counts = {\n      patches: entries.length,\n      applied: 0,\n      errors: [],\n      notApplied: entries.length,\n    }\n\n    entries.forEach(([,patch]) => {\n      if (patch.isAllowed) {\n        // Patch\n        Object.defineProperty(this.owner, patch.key, patch.descriptor)\n\n        // Verify\n        let oDesc = Object.getOwnPropertyDescriptor(this.owner, patch.key)\n        if (this.#equalDescriptors(oDesc, patch.descriptor)) {\n          counts.applied += 1\n          counts.notApplied -= 1\n        }\n        else {\n          counts.errors.push([patch, new Error(\n            `Could not apply patch for key ${patch.key}`\n          )])\n        }\n      }\n    })\n\n    this.patchesApplied = counts.applied\n\n    if (typeof metrics === 'function') {\n      metrics(counts)\n    }\n  }\n\n  /**\n   * Creates an easy to use toggle for working with `Patch` classes\n   *\n   * @param {boolean} preventRevert true if calling stop() on the toggle does not\n   * revert the patch. false, the default, if it should.\n   * @returns {PatchToggle} an instance of PatchToggle wrapped around this instance\n   * of `Patch`\n   * @example const toggle = ObjectExtensions.createToggle().start()\n   */\n  createToggle(preventRevert = false) {\n    return new PatchToggle(this, preventRevert)\n  }\n\n  /**\n   * Reverts all applied patches on the owner object, restoring any overridden\n   * properties to their original state. Optionally a callback can be supplied to\n   * the call to revert. If the callback is a valid function, it will be invoked\n   * with an object containing the results of the reversion of the patch. The\n   * callback receives a single parameter which is an object of counts. It has\n   * the signature:\n   *\n   * ```\n   * type counts = {\n   *   patches: number;\n   *   reverted: number;\n   *   restored: number;\n   *   conflicts: number;\n   *   errors: Array<PatchEntry,Error>;\n   *   stillApplied: number;\n   * }\n   * ```\n   *\n   * While the keys may be obvious to some, `patches` is the count of patches\n   * this instance tracks. `reverted` is the number of patches that were removed'\n   * `restored` is the number of originally conflicting keys that were restored.\n   * `conflicts` is the total number of conflicts expected. `errors` is an array of\n   * arrays where the first element is the `PatchEntry` and the second element\n   * is an `Error` indicating the problem. Lastly `stillApplied` is the number of\n   * patchesApplied still tracked. If this is greater than zero, you can assume\n   * something went wrong.\n   *\n   * Additional logic that should track\n   * ```\n   *   \u2022 patches should === reverted when done\n   *   \u2022 restored should === conflicts when done\n   *   \u2022 errors.length should be 0 when done\n   *   \u2022 stillApplied should be 0 when done\n   * ```\n   *\n   * @param {function} metrics - a callback which receives a status of the\n   * `revert` action if supplied. This callback will not be invoked, nor will\n   * any of the other logic be captured, if {@link applied} returns false\n   */\n  revert(metrics) {\n    if (!this.applied) {\n      return\n    }\n\n    const entries = this.entries\n    const conflicts = this.conflicts\n\n    const counts = {\n      patches: entries.length,\n      reverted: 0,\n      restored: 0,\n      conflicts: conflicts.length,\n      errors: [],\n      stillApplied: 0,\n    }\n\n    entries.forEach(([,patch]) => {\n      const successful = delete this.owner[patch.key]\n      if (successful) {\n        this.patchesApplied -= 1\n        counts.reverted += 1\n      }\n      else {\n        counts.errors.push([patch, new Error(\n          `Failed to revert patch ${patch.key}`\n        )])\n      }\n    })\n\n    conflicts.forEach(([,patch]) => {\n      Object.defineProperty(this.owner, patch.key, patch.descriptor)\n      const appliedDescriptor = Object.getOwnPropertyDescriptor(this.owner, patch.key)\n      if (this.#equalDescriptors(patch.descriptor, appliedDescriptor)) {\n        counts.restored += 1\n      }\n      else {\n        counts.errors.push([patch, new Error(\n          `Failed to restore original ${patch.key}`\n        )])\n      }\n    })\n\n    counts.stillApplied = this.patchesApplied\n    if (typeof metrics === 'function') {\n      metrics(counts)\n    }\n  }\n\n  /**\n   * Removes this Patch instance from being tracked amongst all the tracked Patch\n   * instances. The JavaScript virtual machine will clean this instance up once\n   * nothing else is holding a reference to it.\n   */\n  release() {\n    const patches = Patch.patches.get(this.owner)\n    patches.splice(patches.find(e => e === this), 1)\n  }\n\n  /**\n   * The object to which the patches are applied.\n   */\n  owner = null\n\n  /**\n   * Additional options for patching behavior.\n   */\n  options = null\n\n  #equalDescriptors(left, right) {\n    if (!left || !right) {\n      return false\n    }\n\n    let circuit = true\n\n    circuit = circuit && left.configurable === right.configurable\n    circuit = circuit && left.enumerable === right.enumerable\n    circuit = circuit && left.value === right.value\n    circuit = circuit && left.writable === right.writable\n    circuit = circuit && left.get === right.get\n    circuit = circuit && left.set === right.set\n\n    return circuit\n  }\n\n  /**\n   * A global mapping of all patches in play\n   */\n  static patches = new Map()\n\n  /**\n   * Applies all patches associated with a given owner object. This method\n   * is used to enable all patches for a specific owner if they have been\n   * previously registered.\n   *\n   * @param {object} owner The object whose patches are to be applied.\n   */\n  static enableFor(owner) {\n    if (Patch.patches.has(owner)) {\n      for (const patch of Patch.patches.get(owner)) {\n        patch.apply()\n      }\n    }\n  }\n\n  /**\n   * Reverts all patches associated with a given owner object. This method\n   * is used to disable all patches for a specific owner if they have been\n   * previously applied.\n   *\n   * @param {object} owner The object whose patches are to be reverted.\n   */\n  static disableFor(owner) {\n    if (Patch.patches.has(owner)) {\n      for (const patch of Patch.patches.get(owner)) {\n        patch.revert()\n      }\n    }\n  }\n}", "import { CannotBeExtendedError } from \"./errors/CannotBeExtendedError.js\"\nimport { MissingOwnerValue } from './errors/MissingOwnerValue.js'\nimport { Patch } from './patch.js'\n\n/**\n * The Extension class, inheriting from the Patch class, is specifically designed\n * for extending properties or methods of a given object. It facilitates the\n * extension process by determining the target key and value for the extension and\n * ensuring the target property is writable and configurable. If these conditions\n * are not met, the class throws a CannotBeExtendedError. This class is useful\n * in scenarios like testing, dynamic behavior adjustments, or managing complex\n * object configurations.\n */\nexport class Extension extends Patch {\n  /**\n   * Constructs a new Extension instance. This constructor initializes the extension\n   * by determining the target key and value for the extension and ensuring that\n   * the property to be extended is configurable and writable. It throws an error\n   * if these conditions are not satisfied. The constructor leverages the Patch\n   * class's functionalities to manage the extension effectively.\n   *\n   * @param {Function|string} keyClassOrFn - The key, class, or function to be\n   * used for the extension. If a function or class is provided, its name is used\n   * as the key.\n   * @param {*} value - The value or method to be used for the extension.\n   * @param {object} [owner=globalThis] - The object to which the extension will\n   * be applied.\n   * @param {object} [options={}] - Additional options for the extension behavior.\n   * @throws {CannotBeExtendedError} If the target property is not writable or\n   * configurable.\n   * @throws {MissingOwnerValue} If the `keyClassOrFn` value is null or there\n   * is an error determining the key and extension values, MissingOwnerValue is\n   * thrown.\n   */\n  constructor(keyClassOrFn, value, owner = globalThis, options = {}) {\n    let { key, extension, valid } = Extension.determineInput(keyClassOrFn)\n    extension = value || extension\n\n    if (!valid) {\n      throw new MissingOwnerValue(owner, key)\n    }\n\n    const descriptor = Object.getOwnPropertyDescriptor(owner, key)\n    if (descriptor) {\n      if (\n        (Reflect.has(descriptor, 'writable') && !descriptor.writable) ||\n        (Reflect.has(descriptor, 'configurable') && !descriptor.configurable)\n      ) {\n        throw new CannotBeExtendedError(owner, key)\n      }\n    }\n\n    super(owner, { [key]: extension }, options)\n    this.key = key\n  }\n\n  /**\n   * Determines the input type for the extension. This method processes the input\n   * and identifies the key for the extension and the associated value or method.\n   * It supports inputs as either a string key or a function/class, providing\n   * flexibility in defining extensions.\n   *\n   * @param {Function|string} keyClassOrFn - The key, class, or function provided\n   * as input. If a function or class is provided, its name is used as the key.\n   * containing the determined key, the extension value/method, and a validity flag\n   * indicating whether the input is usable.\n   * @returns {{key: string|null, extension: *|null, valid: boolean}} An object\n   */\n  static determineInput(keyClassOrFn) {\n    let input = { key: null, extension: null, valid: false }\n\n    if (keyClassOrFn instanceof Function) {\n      input = { key: keyClassOrFn.name, extension: keyClassOrFn, valid: true }\n    }\n    else if (typeof keyClassOrFn === 'string' || keyClassOrFn instanceof String) {\n      input = { key: keyClassOrFn, extension: null, valid: true }\n    }\n\n    return input\n  }\n\n  /**\n   * Custom inspect function for Node.js that provides a formatted representation\n   * of the Extension instance, primarily for debugging purposes.\n   *\n   * @param {number} depth The depth to which the object should be formatted.\n   * @param {object} options Formatting options.\n   * @param {function} inspect The inspection function to format the object.\n   * @returns {string} A formatted string representing the Extension instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    return `Extension<${this.key}>`\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Provides the class name when the\n   * object is converted to a string, typically used for debugging and logging.\n   *\n   * @returns {string} The class name of the Extension instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}"],
  "mappings": "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",
  "names": ["src_exports", "__export", "Errors", "Extension", "Patch", "PatchEntry", "PatchToggle", "typeOf", "CannotBeExtendedError", "owner", "key", "typeOf", "MissingOwnerValue", "owner", "key", "PatchToggle", "patch", "preventRevert", "depth", "options", "inspect", "objName", "status", "PatchEntry", "property", "owningObject", "condition", "isNullish", "value", "isKey", "types", "f", "isObject", "depth", "options", "inspect", "type", "writable", "Patch", "_Patch", "owner", "patches", "options", "globalCondition", "key", "condition", "PatchEntry", "error", "acc", "patchEntry", "metrics", "entries", "counts", "patch", "oDesc", "#equalDescriptors", "preventRevert", "PatchToggle", "conflicts", "appliedDescriptor", "left", "right", "circuit", "Extension", "_Extension", "Patch", "keyClassOrFn", "value", "owner", "options", "key", "extension", "valid", "MissingOwnerValue", "descriptor", "CannotBeExtendedError", "input", "depth", "inspect", "Errors", "CannotBeExtendedError", "MissingOwnerValue"]
}
